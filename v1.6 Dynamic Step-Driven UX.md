# v1.6 Milestone Prompt — Dynamic Step-Driven UX

## Priority: P2 (Requires Workflow Orchestrator)

## Context

This is a React + Express monorepo chat app. By this milestone, the backend is a **Workflow Orchestrator** (v1.5) that:
- Enriches user input with accumulated context before sending to Copilot
- Parses structured output from Copilot responses (action signals, data, next-step prompts)
- Returns `workflowState` alongside messages in every API response

The client (v1.1) currently renders an open-ended chat: text bubbles, Adaptive Cards, and a free-form text input. It has **no concept of workflow phases, progress, or server-driven prompts**.

The target architecture (`p1.1 flow architecture.md`) shows the backend driving the conversation: `"Ask next question (step-driven)"` → user answers → research via Copilot → `"Next prompt / progress / results (text + data + cards)"`.

Because the workflows are **dynamic and AI-driven** (Copilot determines the next step), the UX must be adaptive — the client renders whatever the orchestrator returns, not a hardcoded sequence of screens.

## What to Build

### Extended Message Schema

Add workflow-aware fields to the API response so the client can render appropriate UI:

**`shared/src/schemas/workflow.ts`** (extend from v1.5):

```typescript
// Workflow state returned in every API response
const WorkflowStateSchema = z.object({
  status: z.enum(['active', 'completed', 'error']),
  currentPhase: z.string().nullable(),           // e.g., "Gathering requirements"
  progress: z.number().min(0).max(1).nullable(), // 0-1 if estimable, null if unknown
  collectedData: z.record(z.unknown()),          // All data gathered so far
  suggestedInputType: z.enum([
    'text',           // Free-form text (default)
    'choice',         // Pick from options
    'confirmation',   // Yes/no
    'none'            // No user input needed (processing/complete)
  ]).nullable(),
  choices: z.array(z.string()).nullable(),        // Options for 'choice' input type
});
```

Update `SendMessageResponse` and `CardActionResponse` to include `workflowState`.

### Workflow-Aware Chat Shell

Update `client/src/components/ChatShell.tsx`:

- Receive `workflowState` from `useChatApi` hook responses
- Pass workflow state to new child components (progress bar, dynamic input)
- When `workflowState.status === 'completed'`, show a completion summary view
- When `workflowState.status === 'error'`, show an error state with retry option

### Progress Indicator Component

Create `client/src/components/WorkflowProgress.tsx`:

- Renders above the transcript when a workflow is active
- Shows `currentPhase` as a label (e.g., "Gathering requirements")
- Shows a progress bar when `progress` is not null (0-100%)
- Shows an indeterminate/pulsing indicator when `progress` is null but workflow is active
- Collapses/hides when no workflow is active (pure chat mode)
- Animates transitions between phases smoothly

### Dynamic Input Component

Evolve `client/src/components/ChatInput.tsx` to support multiple input modes:

- **`text` mode** (default, current behavior): Free-form textarea with send button
- **`choice` mode**: Render `choices` as clickable pill buttons. Selecting one sends it as the user's message. Still allow free-text override via a "Type instead..." toggle.
- **`confirmation` mode**: Render two buttons: "Yes" / "No" (or "Confirm" / "Go back"). Map to text messages sent to the orchestrator.
- **`none` mode**: Input area is hidden or disabled. Shows a "Processing..." or "Complete" message. Used when Copilot is computing or the workflow is finished.

The server drives the input mode via `workflowState.suggestedInputType`. The client should **always allow free-text as a fallback** — the user is never trapped by the suggested input type.

### Workflow Completion View

Create `client/src/components/WorkflowComplete.tsx`:

- Rendered when `workflowState.status === 'completed'`
- Shows a summary of `collectedData` in a clean, readable format (key-value pairs or a structured card)
- "Start new conversation" button to reset
- "Download summary" button (JSON export, similar to existing MetadataPane download)

### Updated useChatApi Hook

Extend `client/src/hooks/useChatApi.ts`:

- Add `workflowState` to the reducer state
- New actions: `WORKFLOW_STATE_UPDATE`, `WORKFLOW_COMPLETE`, `WORKFLOW_ERROR`
- On every `send`/`cardAction` response, extract and dispatch `workflowState`
- Expose `workflowState` from the hook return value
- Add `resetConversation()` function for starting fresh after completion

### Updated MetadataPane

Extend `client/src/components/MetadataPane.tsx`:

- Add a "Workflow Data" section showing `collectedData` as it accumulates
- Each key-value pair appears as it's added (animated)
- This gives the user real-time visibility into what the AI has gathered
- Keep the existing card action timeline below the workflow data

### Transcript Enhancements

Update `client/src/components/TranscriptView.tsx` and `MessageBubble.tsx`:

- **Phase dividers**: When `currentPhase` changes between messages, render a subtle divider line with the new phase name (similar to date dividers in chat apps)
- **System messages**: Render orchestrator status messages (e.g., "Researching your question...") differently from user/assistant messages — centered, muted text, no bubble

## Constraints

- **The client must work without workflow state.** If the backend returns no `workflowState` (null/undefined), the client behaves exactly like v1.1 — pure open-ended chat. All workflow UI is progressive enhancement.
- **Do NOT hardcode workflow phases in the client.** The client renders whatever the server returns. Phase names, progress values, and input types are all server-driven.
- **Free-text fallback is always available.** Even in `choice` or `confirmation` mode, the user can type a custom response. The server must handle unexpected text input gracefully.
- Maintain all existing accessibility features (ARIA labels, keyboard navigation, focus management).
- The choice pills and confirmation buttons must be keyboard accessible (tab + enter).
- Responsive design: all new components must work at 360px, 768px, and 1280px.
- Dark/light theme: all new components must respect the existing theme system (`[data-theme]` CSS tokens).
- No new npm dependencies for the client unless absolutely necessary — use existing React 18 + CSS.

## Success Criteria

1. When backend returns `workflowState`, progress indicator shows current phase and progress
2. When `suggestedInputType: 'choice'`, client renders choice pills; selecting one sends the choice as text
3. When `suggestedInputType: 'confirmation'`, client renders Yes/No buttons
4. When `suggestedInputType: 'none'`, input area is disabled with appropriate messaging
5. Free-text input is always available as a fallback regardless of suggested input type
6. Phase transitions show divider lines in the transcript
7. Workflow completion shows a summary view with collected data
8. MetadataPane shows accumulated workflow data in real-time
9. When no `workflowState` is returned, the UI is identical to v1.1 (no regression)
10. All new components are responsive (360px, 768px, 1280px) and theme-aware
11. All new interactive elements are keyboard accessible
12. Unit tests for new components (WorkflowProgress, dynamic ChatInput modes, WorkflowComplete)
13. Integration test: simulate a multi-step workflow and verify UI transitions

## Dependencies

- v1.5 (Workflow Orchestrator) — the server must return `workflowState` in API responses
- v1.2 (Authentication) — for user-scoped workflows
- v1.4 (State Store) — for persistent workflow state

## Risks

- **AI unpredictability**: Copilot may return inconsistent `suggestedInputType` values or change phases unexpectedly. The client must handle rapid state changes gracefully (debounce progress updates, animate transitions).
- **Choice overflow**: If Copilot returns too many choices (>6), the pill layout breaks on mobile. Implement a max visible count with a "Show more" toggle.
- **Progress estimation**: Dynamic workflows make progress hard to estimate. The indeterminate indicator (null progress) will be the common case. Don't over-index on the progress bar — the phase label is more useful.
- **Data display**: `collectedData` may contain deeply nested objects. The MetadataPane display should handle 2-3 levels of nesting, then show "View full data" with a JSON viewer for deeper structures.
