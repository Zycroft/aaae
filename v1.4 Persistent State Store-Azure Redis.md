# v1.4 Milestone Prompt — Persistent State Store (Azure Cache for Redis)

## Priority: P1 (Required before Workflow Orchestrator)

## Context

This is a React + Express monorepo chat app. The server currently uses an **in-memory LRU cache** (`server/src/store/InMemoryStore.ts`, max 100 entries) for conversation state. This means:
- All conversations are lost on server restart
- Cannot scale horizontally (each instance has its own cache)
- No audit trail or conversation history
- State is limited to `{ externalId, sdkConversationRef, history: NormalizedMessage[] }`

The target architecture requires a **Workflow State Store (Redis / DB)** that:
- Persists conversation and workflow state across server restarts
- Supports the expanded state model needed by the Workflow Orchestrator (v1.5)
- Runs on Azure infrastructure (Azure Cache for Redis on App Service)

The system uses **Entra External ID (CIAM)** for authentication (v1.2), so state must be associated with authenticated user identities.

## What to Build

### Redis Store Implementation

- Add `ioredis` to `server/` dependencies
- Create `server/src/store/RedisStore.ts` implementing the existing `ConversationStore` interface
- Redis connection configuration via env vars:
  - `REDIS_URL` — Full connection string (e.g., `rediss://:password@host:6380`)
  - `REDIS_KEY_PREFIX` — Namespace prefix (default: `copilot:conv:`)
- Key schema: `{prefix}{conversationId}` → JSON-serialized conversation state
- TTL: configurable via `CONVERSATION_TTL_SECONDS` (default: 86400 = 24 hours)
- Serialize/deserialize with proper type safety (the `sdkConversationRef` is opaque — store as JSON string)
- Handle connection failures gracefully:
  - Log and retry on transient errors
  - Return 503 Service Unavailable if Redis is down (don't silently fall back to in-memory)
  - Implement a health check endpoint that verifies Redis connectivity

### Expanded State Model

Prepare the state model for the Workflow Orchestrator (v1.5) while remaining backward-compatible with v1.1's simple chat:

```typescript
interface StoredConversation {
  // Existing fields (keep working)
  externalId: string;
  sdkConversationRef: unknown;
  history: NormalizedMessage[];

  // New fields (v1.4)
  userId: string;              // From JWT sub claim (v1.2)
  tenantId: string;            // From JWT tid claim (v1.2)
  createdAt: string;           // ISO 8601
  updatedAt: string;           // ISO 8601
  status: 'active' | 'completed' | 'abandoned';

  // Workflow fields (optional, used by v1.5)
  workflowId?: string;
  currentStep?: string;
  stepData?: Record<string, unknown>;
  metadata?: Record<string, unknown>;
}
```

- Add a Zod schema for `StoredConversation` in `shared/src/schemas/conversation.ts`
- Existing conversations without new fields must still load (all new fields have defaults or are optional)

### Store Factory Pattern

- Create `server/src/store/createStore.ts` — factory function that returns either `RedisStore` or `InMemoryStore` based on configuration:
  - If `REDIS_URL` is set → `RedisStore`
  - If `REDIS_URL` is not set → `InMemoryStore` (for local development)
- Update `server/src/store/index.ts` to use the factory
- Log which store backend is active on server startup

### User-Scoped Queries

- Add a method to `ConversationStore` interface: `listByUser(userId: string): Promise<StoredConversation[]>`
- This enables future features: conversation history, resume previous conversations
- Redis implementation: use a secondary index — a sorted set `{prefix}user:{userId}` with conversation IDs scored by `updatedAt` timestamp
- Limit: return most recent 50 conversations per user

### Health Check

- Extend `/health` endpoint to include Redis connectivity status:
  ```json
  { "status": "ok", "redis": "connected", "uptime": 12345 }
  ```
- When Redis is unavailable: `{ "status": "degraded", "redis": "disconnected" }`

### Wire Into Existing Routes

- Update `server/src/routes/chat.ts` to populate new fields when creating/updating conversations:
  - Set `userId` and `tenantId` from `req.user` (from auth middleware, v1.2)
  - Set `createdAt` on `/start`, update `updatedAt` on `/send` and `/card-action`
  - Set `status` to `'active'` on creation
- If v1.2 is not yet deployed, use placeholder values (`userId: 'anonymous'`, `tenantId: 'dev'`) so the store works without auth

## Constraints

- **Do NOT replace InMemoryStore** — keep it as the default for local development. The factory pattern selects based on env vars.
- **Do NOT add Redis as a required dependency** — it should be optional. `ioredis` should be dynamically imported or the Redis store should be in a separate module.
- The `sdkConversationRef` field is opaque (type `unknown`) — serialize as JSON string, deserialize back. Do NOT attempt to parse its internals.
- All Redis operations must have timeouts (default: 5 seconds). Don't let a slow Redis hang the API.
- No Redis Cluster support needed yet — single-node Azure Cache for Redis is sufficient for v1.4.

## Success Criteria

1. With `REDIS_URL` set: conversations persist across server restarts
2. With `REDIS_URL` unset: existing in-memory behavior unchanged (no regression)
3. Conversation state includes `userId`, `tenantId`, `createdAt`, `updatedAt`, `status`
4. `listByUser()` returns conversations for a specific user, sorted by recency
5. TTL-based expiry: conversations auto-expire after configured duration
6. `/health` endpoint reports Redis connectivity status
7. Server returns 503 (not a crash) when Redis is unreachable
8. Unit tests for RedisStore (using `ioredis-mock` or similar)
9. Integration test: create conversation → restart server → conversation still exists
10. Updated `.env.example` with Redis configuration
11. CI continues to pass (tests run without Redis using InMemoryStore)

## Dependencies

- v1.2 (Authentication) for `userId`/`tenantId` — but store works without auth using placeholder values
- Azure Cache for Redis instance for production — not needed for development/testing

## Risks

- Redis serialization of `sdkConversationRef`: the Copilot SDK stores internal state in this object. Verify that JSON.parse(JSON.stringify(ref)) produces a usable reference — if not, the SDK may need to re-establish the conversation from scratch (test this explicitly).
- Azure Cache for Redis requires TLS (`rediss://` protocol, port 6380) — ensure `ioredis` is configured with `tls: {}` for Azure connections.
- Secondary indexes (sorted sets for user lookup) add write overhead — acceptable at current scale but should be noted.
