---
phase: 14-redis-error-differentiation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/utils/errorDetection.ts
  - server/src/utils/errorDetection.test.ts
  - server/src/routes/chat.ts
  - server/src/routes/orchestrate.ts
autonomous: true
requirements:
  - RESIL-01

must_haves:
  truths:
    - "When a Redis error occurs in any chat route, the response is 503 Service Unavailable — not 502"
    - "When a Copilot Studio error occurs, routes still return 502 Bad Gateway (no regression)"
    - "isRedisError() correctly identifies ioredis TimeoutError, ConnectionError, and network-level errors (ECONNREFUSED etc.)"
    - "isRedisError() returns false for generic errors and Copilot SDK errors"
  artifacts:
    - path: "server/src/utils/errorDetection.ts"
      provides: "isRedisError(err: unknown): boolean utility function"
      exports: ["isRedisError"]
    - path: "server/src/utils/errorDetection.test.ts"
      provides: "Unit tests for isRedisError covering all ioredis error types"
      contains: "TimeoutError, ConnectionError, ECONNREFUSED"
    - path: "server/src/routes/chat.ts"
      provides: "Updated catch blocks in /start, /send, /card-action using isRedisError"
      contains: "503"
    - path: "server/src/routes/orchestrate.ts"
      provides: "Updated catch block in /orchestrate using isRedisError"
      contains: "503"
  key_links:
    - from: "server/src/routes/chat.ts"
      to: "server/src/utils/errorDetection.ts"
      via: "import { isRedisError } from '../utils/errorDetection.js'"
      pattern: "isRedisError"
    - from: "server/src/routes/orchestrate.ts"
      to: "server/src/utils/errorDetection.ts"
      via: "import { isRedisError } from '../utils/errorDetection.js'"
      pattern: "isRedisError"
---

<objective>
Close the RESIL-01 gap: route error handlers distinguish Redis errors from Copilot Studio errors and return 503 Service Unavailable for Redis unavailability instead of 502 Bad Gateway, enabling operators to differentiate backend failures in monitoring.

Purpose: Currently all errors in route catch blocks return 502, hiding Redis failures from monitoring. Operators cannot tell whether a failure is a Copilot Studio problem (502) or a Redis store problem (503).

Output: errorDetection.ts utility + unit tests + 4 updated route catch blocks (3 in chat.ts, 1 in orchestrate.ts)
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/14-redis-error-differentiation/14-RESEARCH.md
@server/src/routes/chat.ts
@server/src/routes/orchestrate.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create isRedisError utility with exhaustive unit tests</name>
  <files>
    server/src/utils/errorDetection.ts
    server/src/utils/errorDetection.test.ts
  </files>
  <action>
    Create `server/src/utils/errorDetection.ts`:

    ```typescript
    import { TimeoutError } from 'ioredis';

    /**
     * Returns true if the error originated from the Redis store backend (ioredis).
     *
     * Used in route catch blocks to select HTTP status code:
     *   - Redis errors  → 503 Service Unavailable
     *   - Other errors  → 502 Bad Gateway (Copilot Studio or application)
     *
     * Detects:
     * 1. ioredis TimeoutError (instanceof) — command exceeded commandTimeout
     * 2. ioredis ConnectionError (error.name) — cannot reach Redis
     * 3. ioredis RedisError (error.name) — Redis protocol errors
     * 4. Network-level connection failures (ECONNREFUSED, ECONNRESET, ETIMEDOUT, EHOSTUNREACH, ENOTFOUND)
     *
     * RESIL-01
     */
    export function isRedisError(err: unknown): boolean {
      if (!(err instanceof Error)) return false;

      // ioredis TimeoutError class — command exceeded commandTimeout
      if (err instanceof TimeoutError) {
        return true;
      }

      // ioredis named errors (ConnectionError, RedisError)
      const name = err.name;
      if (name === 'ConnectionError' || name === 'RedisError') {
        return true;
      }

      // Network-level connection failures
      const message = err.message;
      if (/ECONNREFUSED|ECONNRESET|ETIMEDOUT|EHOSTUNREACH|ENOTFOUND/.test(message)) {
        return true;
      }

      return false;
    }
    ```

    Create `server/src/utils/errorDetection.test.ts`:

    ```typescript
    import { describe, it, expect } from 'vitest';
    import { TimeoutError } from 'ioredis';
    import { isRedisError } from './errorDetection.js';

    describe('isRedisError()', () => {
      it('returns true for ioredis TimeoutError (instanceof)', () => {
        const err = new TimeoutError('Command timeout');
        expect(isRedisError(err)).toBe(true);
      });

      it('returns true for ConnectionError by name', () => {
        const err = new Error('connect ECONNREFUSED 127.0.0.1:6380');
        err.name = 'ConnectionError';
        expect(isRedisError(err)).toBe(true);
      });

      it('returns true for RedisError by name', () => {
        const err = new Error('READONLY You cannot write against a read only replica');
        err.name = 'RedisError';
        expect(isRedisError(err)).toBe(true);
      });

      it('returns true for ECONNREFUSED in message', () => {
        const err = new Error('connect ECONNREFUSED 127.0.0.1:6380');
        expect(isRedisError(err)).toBe(true);
      });

      it('returns true for ECONNRESET in message', () => {
        const err = new Error('read ECONNRESET');
        expect(isRedisError(err)).toBe(true);
      });

      it('returns true for ETIMEDOUT in message', () => {
        const err = new Error('connect ETIMEDOUT');
        expect(isRedisError(err)).toBe(true);
      });

      it('returns true for EHOSTUNREACH in message', () => {
        const err = new Error('connect EHOSTUNREACH');
        expect(isRedisError(err)).toBe(true);
      });

      it('returns true for ENOTFOUND in message', () => {
        const err = new Error('getaddrinfo ENOTFOUND my-redis.cache.windows.net');
        expect(isRedisError(err)).toBe(true);
      });

      it('returns false for generic Error', () => {
        const err = new Error('Something went wrong');
        expect(isRedisError(err)).toBe(false);
      });

      it('returns false for Copilot SDK authentication error', () => {
        const err = new Error('Authentication failed: invalid token');
        expect(isRedisError(err)).toBe(false);
      });

      it('returns false for Copilot Studio timeout (non-Redis)', () => {
        const err = new Error('Request to Copilot Studio timed out after 30s');
        // Note: this does NOT match ETIMEDOUT (no ETIMEDOUT in message)
        expect(isRedisError(err)).toBe(false);
      });

      it('returns false for non-Error values (null, string, number)', () => {
        expect(isRedisError(null)).toBe(false);
        expect(isRedisError('error string')).toBe(false);
        expect(isRedisError(42)).toBe(false);
        expect(isRedisError(undefined)).toBe(false);
      });
    });
    ```

    Note: `ioredis` is already a production dependency. `TimeoutError` is exported from ioredis v5.
  </action>
  <verify>
    cd /Users/zycroft/Documents/PA/aaae/server && npm test 2>&1 | grep -E "PASS|FAIL|errorDetection"
    Expected: all errorDetection tests pass (14 test cases)
  </verify>
  <done>
    server/src/utils/errorDetection.ts exports isRedisError(). All 14 test cases pass: TimeoutError → true, ConnectionError by name → true, RedisError by name → true, all network error patterns (ECONNREFUSED, ECONNRESET, ETIMEDOUT, EHOSTUNREACH, ENOTFOUND) → true, generic Error → false, Copilot auth error → false, non-Error values → false.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update 4 route catch blocks to return 503 for Redis errors</name>
  <files>
    server/src/routes/chat.ts
    server/src/routes/orchestrate.ts
  </files>
  <action>
    Update `server/src/routes/chat.ts`:

    1. Add import at top (after existing imports):
       ```typescript
       import { isRedisError } from '../utils/errorDetection.js';
       ```

    2. Update the catch block in `chatRouter.post('/start', ...)` (currently line 71–74):
       ```typescript
       } catch (err) {
         console.error('[chat/start] Error starting conversation:', err);
         if (isRedisError(err)) {
           res.status(503).json({ error: 'Service Unavailable: Redis backend offline' });
         } else {
           res.status(502).json({ error: 'Failed to start conversation with Copilot Studio' });
         }
       }
       ```

    3. Update the catch block in `chatRouter.post('/send', ...)` (currently line 133–135):
       ```typescript
       } catch (err) {
         console.error('[chat/send] Error sending message:', err);
         if (isRedisError(err)) {
           res.status(503).json({ error: 'Service Unavailable: Redis backend offline' });
         } else {
           res.status(502).json({ error: 'Failed to send message to Copilot Studio' });
         }
       }
       ```

    4. Update the catch block in `chatRouter.post('/card-action', ...)` (currently line 201–203):
       ```typescript
       } catch (err) {
         console.error('[chat/card-action] Error forwarding card action:', err);
         if (isRedisError(err)) {
           res.status(503).json({ error: 'Service Unavailable: Redis backend offline' });
         } else {
           res.status(502).json({ error: 'Failed to forward card action to Copilot Studio' });
         }
       }
       ```

    Update `server/src/routes/orchestrate.ts`:

    1. Add import at top (after existing imports):
       ```typescript
       import { isRedisError } from '../utils/errorDetection.js';
       ```

    2. Update the catch block in `orchestrateRouter.post('/', ...)` (currently line 127–129):
       ```typescript
       } catch (err) {
         console.error('[chat/orchestrate] Error:', err);
         if (isRedisError(err)) {
           res.status(503).json({ error: 'Service Unavailable: Redis backend offline' });
         } else {
           res.status(502).json({ error: 'Failed to communicate with Copilot Studio' });
         }
       }
       ```

    Do NOT change:
    - The 404 returns for missing conversations (those are correct, not Redis errors)
    - The 400 returns for invalid request bodies
    - The 403 returns for card action allowlist rejection
    - Any logic outside the catch blocks
    - Error log messages (only the response status/body changes)
  </action>
  <verify>
    cd /Users/zycroft/Documents/PA/aaae/server && npm test 2>&1 | tail -20
    grep -n "503\|isRedisError" /Users/zycroft/Documents/PA/aaae/server/src/routes/chat.ts
    grep -n "503\|isRedisError" /Users/zycroft/Documents/PA/aaae/server/src/routes/orchestrate.ts
    Expected: npm test passes, grep shows 503 and isRedisError in all 4 catch blocks
  </verify>
  <done>
    All 4 route catch blocks (/start, /send, /card-action in chat.ts; / in orchestrate.ts) call isRedisError(err) and return 503 for Redis errors, 502 for all other errors. npm test passes across all workspaces. The word "503" appears exactly 4 times in routes (once per catch block). isRedisError import appears in both chat.ts and orchestrate.ts.
  </done>
</task>

</tasks>

<verification>
Run full test suite to confirm no regressions:

```bash
cd /Users/zycroft/Documents/PA/aaae && npm test
```

Expected: All existing tests pass (RedisStore.test.ts, factory.test.ts, auth.test.ts, etc.) plus new errorDetection.test.ts tests pass.

Confirm 503 wiring in routes:
```bash
grep -n "503" /Users/zycroft/Documents/PA/aaae/server/src/routes/chat.ts
grep -n "503" /Users/zycroft/Documents/PA/aaae/server/src/routes/orchestrate.ts
```

Expected: 3 occurrences in chat.ts (one per catch block), 1 in orchestrate.ts.

Confirm isRedisError import in both routes:
```bash
grep -n "isRedisError" /Users/zycroft/Documents/PA/aaae/server/src/routes/chat.ts
grep -n "isRedisError" /Users/zycroft/Documents/PA/aaae/server/src/routes/orchestrate.ts
```
</verification>

<success_criteria>
1. server/src/utils/errorDetection.ts exists and exports isRedisError()
2. isRedisError() returns true for: TimeoutError (instanceof), ConnectionError (name), RedisError (name), ECONNREFUSED/ECONNRESET/ETIMEDOUT/EHOSTUNREACH/ENOTFOUND messages
3. isRedisError() returns false for: generic Error, Copilot auth errors, null/string/number
4. All 3 catch blocks in chat.ts return 503 for Redis errors, 502 otherwise
5. The catch block in orchestrate.ts returns 503 for Redis errors, 502 otherwise
6. npm test passes (all workspaces, no regressions)
7. RESIL-01 requirement satisfied: server returns 503 when Redis is unreachable
</success_criteria>

<output>
After completion, create `.planning/phases/14-redis-error-differentiation/14-01-SUMMARY.md` documenting:
- Files created/modified
- isRedisError() error detection strategy (instanceof vs. name vs. message pattern)
- All 4 route catch blocks updated
- Test coverage: which error types were tested
- RESIL-01 closure confirmed
</output>