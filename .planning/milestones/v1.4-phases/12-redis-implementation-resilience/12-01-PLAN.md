---
phase: 12-redis-implementation-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/package.json
  - server/src/config.ts
  - server/src/store/RedisStore.ts
  - server/src/store/factory.ts
  - server/src/store/index.ts
autonomous: true
requirements:
  - STORE-05
  - STORE-06
  - STORE-07
  - QUERY-02
  - QUERY-03
  - RESIL-01
  - RESIL-03

must_haves:
  truths:
    - "RedisConversationStore connects via ioredis using rediss:// TLS URL and rejects non-rediss:// URLs at startup"
    - "set() stores conversation JSON with configurable TTL (default 24h) and updates sorted-set user index atomically via pipeline"
    - "get() retrieves and deserializes conversation using StoredConversationSchema.parse() for Zod validation"
    - "delete() removes conversation key AND sorted-set index entry"
    - "listByUser() returns up to 50 conversations sorted most-recent-first via ZREVRANGEBYSCORE on sorted-set index"
    - "All Redis operations throw on timeout (configurable, default 5s) — errors propagate to route handlers for 503 response"
    - "ioredis retryStrategy reconnects on transient errors with exponential backoff and [STORE] log prefix"
  artifacts:
    - path: "server/src/store/RedisStore.ts"
      provides: "Full RedisConversationStore implementation with ioredis"
      exports:
        - RedisConversationStore
    - path: "server/src/store/factory.ts"
      provides: "Updated factory creating ioredis client with TLS validation"
      exports:
        - createConversationStore
    - path: "server/src/config.ts"
      provides: "REDIS_TTL and REDIS_TIMEOUT env vars"
      contains: "REDIS_TTL"
  key_links:
    - from: "server/src/store/RedisStore.ts"
      to: "@copilot-chat/shared"
      via: "import StoredConversationSchema for deserialization validation"
      pattern: "StoredConversationSchema"
    - from: "server/src/store/factory.ts"
      to: "server/src/store/RedisStore.ts"
      via: "passes ioredis client instance to RedisConversationStore constructor"
      pattern: "new RedisConversationStore"
    - from: "server/src/store/RedisStore.ts"
      to: "ioredis"
      via: "import Redis from ioredis"
      pattern: "import Redis"
---

<objective>
Implement the full RedisConversationStore using ioredis with TLS, TTL, operation timeouts, sorted-set user index, and retry strategy. Replace the Phase 11 stub.

Purpose: This is the core Redis implementation that Phase 12-02 (health + tests) and Phase 13 (route integration) build upon. The factory pattern from Phase 11 already selects the backend — this plan only needs to implement the RedisConversationStore methods and wire the ioredis client.

Output:
- server/src/store/RedisStore.ts (replaced — full ioredis implementation)
- server/src/store/factory.ts (updated — creates ioredis client with TLS validation)
- server/src/store/index.ts (updated — exports Redis client for health check)
- server/src/config.ts (updated — REDIS_TTL, REDIS_TIMEOUT env vars)
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@server/src/store/ConversationStore.ts
@server/src/store/RedisStore.ts
@server/src/store/factory.ts
@server/src/store/index.ts
@server/src/config.ts
@shared/src/schemas/storedConversation.ts
@.planning/phases/12-redis-implementation-resilience/12-RESEARCH.md
@.planning/phases/11-storedconversation-schema-store-abstraction/11-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install ioredis and add Redis config env vars</name>
  <files>
    server/package.json
    server/src/config.ts
  </files>
  <action>
1. Install ioredis as a production dependency:
```bash
cd /Users/zycroft/Documents/PA/aaae/server && npm install ioredis
```

2. Update server/src/config.ts to add Redis configuration env vars after the existing config object properties:

```typescript
// Add these inside the config export object:
REDIS_URL: process.env.REDIS_URL,
REDIS_TTL: Number(process.env.REDIS_TTL ?? 86400),       // Default: 24 hours in seconds
REDIS_TIMEOUT: Number(process.env.REDIS_TIMEOUT ?? 5000), // Default: 5 seconds in milliseconds
```

IMPORTANT: Do NOT add REDIS_URL to the REQUIRED array — it is optional (when absent, InMemoryStore is used). REDIS_TTL and REDIS_TIMEOUT have defaults and do not need validation.

Do NOT add `ioredis-mock` yet — that is a devDependency for Plan 12-02 (tests).
  </action>
  <verify>
Run: `cd /Users/zycroft/Documents/PA/aaae && npm run build 2>&1 | grep -E "error|Error" | head -10` — zero errors.
Run: `grep "ioredis" /Users/zycroft/Documents/PA/aaae/server/package.json` — shows ioredis in dependencies.
Run: `grep "REDIS_TTL" /Users/zycroft/Documents/PA/aaae/server/src/config.ts` — shows the config entry.
  </verify>
  <done>
ioredis installed as production dependency. config.ts exports REDIS_URL, REDIS_TTL (default 86400), and REDIS_TIMEOUT (default 5000). Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement RedisConversationStore + update factory and index</name>
  <files>
    server/src/store/RedisStore.ts
    server/src/store/factory.ts
    server/src/store/index.ts
  </files>
  <action>
**server/src/store/RedisStore.ts** — REPLACE the entire Phase 11 stub with the full implementation:

```typescript
import Redis from 'ioredis';
import { StoredConversationSchema } from '@copilot-chat/shared';
import type { ConversationStore, StoredConversation } from './ConversationStore.js';

/** Redis key prefix for conversation records */
const CONV_PREFIX = 'conv:';

/** Redis key prefix for user sorted-set index */
const USER_PREFIX = 'user:';

/** Suffix for user conversation index keys */
const USER_SUFFIX = ':conversations';

/**
 * Serialize StoredConversation to JSON string for Redis storage.
 * Excludes sdkConversationRef — it holds a live SDK object that is not JSON-serializable.
 * The SDK reference is reconstructed in memory when the conversation is resumed.
 */
function serialize(conversation: StoredConversation): string {
  const { sdkConversationRef, ...serializable } = conversation;
  return JSON.stringify(serializable);
}

/**
 * Deserialize JSON string to StoredConversation.
 * Validates with Zod schema to catch schema drift and apply defaults for missing fields.
 * sdkConversationRef will be undefined after deserialization (z.unknown() accepts undefined).
 */
function deserialize(json: string): StoredConversation {
  const raw = JSON.parse(json);
  return StoredConversationSchema.parse(raw);
}

/**
 * RedisConversationStore — Redis-backed persistent store.
 *
 * Uses ioredis with TLS (rediss://), per-key TTL, operation timeouts,
 * sorted-set secondary index for user-scoped queries, and hard-fail behavior.
 *
 * STORE-05, STORE-06, STORE-07, QUERY-02, QUERY-03, RESIL-01, RESIL-03
 */
export class RedisConversationStore implements ConversationStore {
  private readonly redis: Redis;
  private readonly ttlSeconds: number;

  /**
   * @param redis — Pre-configured ioredis client instance (created by factory)
   * @param ttlSeconds — TTL for conversation keys in seconds (default from config)
   */
  constructor(redis: Redis, ttlSeconds: number) {
    this.redis = redis;
    this.ttlSeconds = ttlSeconds;
  }

  async get(id: string): Promise<StoredConversation | undefined> {
    const json = await this.redis.get(`${CONV_PREFIX}${id}`);
    if (!json) return undefined;
    return deserialize(json);
  }

  async set(id: string, conversation: StoredConversation): Promise<void> {
    const key = `${CONV_PREFIX}${id}`;
    const userKey = `${USER_PREFIX}${conversation.userId}${USER_SUFFIX}`;
    const score = new Date(conversation.updatedAt).getTime();

    // Pipeline for atomic set + zadd + expire
    const pipeline = this.redis.pipeline();
    pipeline.set(key, serialize(conversation), 'EX', this.ttlSeconds);
    pipeline.zadd(userKey, score.toString(), id);
    // User index TTL = conversation TTL + 1 hour buffer to avoid orphaned index entries
    pipeline.expire(userKey, this.ttlSeconds + 3600);

    const results = await pipeline.exec();

    // Check for pipeline errors
    if (results) {
      for (const [err] of results) {
        if (err) throw err;
      }
    }
  }

  async delete(id: string): Promise<void> {
    // Read conversation first to get userId for index cleanup
    const json = await this.redis.get(`${CONV_PREFIX}${id}`);
    if (json) {
      const conversation = deserialize(json);
      const userKey = `${USER_PREFIX}${conversation.userId}${USER_SUFFIX}`;

      const pipeline = this.redis.pipeline();
      pipeline.del(`${CONV_PREFIX}${id}`);
      pipeline.zrem(userKey, id);
      await pipeline.exec();
    } else {
      // Key already gone, just attempt del
      await this.redis.del(`${CONV_PREFIX}${id}`);
    }
  }

  /**
   * List conversations for a user sorted most-recent-first by updatedAt.
   * Returns up to 50 conversations. Filters out IDs whose keys have expired.
   * QUERY-02, QUERY-03
   */
  async listByUser(userId: string): Promise<StoredConversation[]> {
    const userKey = `${USER_PREFIX}${userId}${USER_SUFFIX}`;

    // Get top 50 conversation IDs by score (updatedAt epoch ms), descending
    const ids = await this.redis.zrevrangebyscore(
      userKey, '+inf', '-inf', 'LIMIT', 0, 50
    );
    if (ids.length === 0) return [];

    // Multi-get all conversations via pipeline
    const pipeline = this.redis.pipeline();
    for (const id of ids) {
      pipeline.get(`${CONV_PREFIX}${id}`);
    }
    const results = await pipeline.exec();

    if (!results) return [];

    return results
      .map(([err, json]) => {
        if (err || !json) return null;
        try {
          return deserialize(json as string);
        } catch {
          return null; // Skip conversations that fail Zod validation
        }
      })
      .filter((c): c is StoredConversation => c !== null);
  }
}
```

Critical implementation notes:
- Constructor takes a pre-built ioredis `Redis` instance (not a URL) — the factory handles client creation and TLS validation.
- `serialize()` destructures out `sdkConversationRef` before JSON.stringify — this field holds live SDK objects that are not JSON-safe.
- `deserialize()` uses `StoredConversationSchema.parse()` for Zod validation — catches schema drift and applies defaults.
- `set()` uses a pipeline for atomic SET + ZADD + EXPIRE — reduces round trips and ensures consistency.
- `listByUser()` filters null results from expired keys that remain in the sorted set.
- All Redis errors propagate up naturally — no try/catch in store methods. Express error handler returns 503.

---

**server/src/store/factory.ts** — REPLACE entirely:

```typescript
import Redis from 'ioredis';
import { InMemoryConversationStore } from './InMemoryStore.js';
import { RedisConversationStore } from './RedisStore.js';
import type { ConversationStore } from './ConversationStore.js';
import { config } from '../config.js';

/** The ioredis client instance — null when using InMemoryStore */
let redisClient: Redis | null = null;

/**
 * createConversationStore — selects the active store backend from environment.
 *
 * Selection:
 *   REDIS_URL set   → RedisConversationStore (Azure Cache for Redis)
 *   REDIS_URL absent → InMemoryConversationStore (LRU, local dev / CI)
 *
 * Never both. Never silent fallback on Redis failure (returns 503).
 * Called once at module load time; result exported as singleton from store/index.ts.
 *
 * STORE-03, STORE-04, STORE-05
 */
export function createConversationStore(): ConversationStore {
  const redisUrl = config.REDIS_URL;

  if (redisUrl) {
    // Validate TLS scheme — Azure Cache for Redis requires rediss://
    const url = new URL(redisUrl);
    if (url.protocol !== 'rediss:') {
      console.error(
        `[STORE] FATAL: Invalid REDIS_URL scheme "${url.protocol}". Azure Cache requires rediss:// (TLS on port 6380).`
      );
      process.exit(1);
    }

    redisClient = new Redis(redisUrl, {
      commandTimeout: config.REDIS_TIMEOUT,
      connectTimeout: 10000, // 10 seconds for initial connection
      maxRetriesPerRequest: 3,
      retryStrategy(times: number) {
        if (times > 10) {
          console.error(`[STORE] Redis reconnection failed after ${times} attempts. Giving up.`);
          return null; // Stop retrying
        }
        const delay = Math.min(times * 200, 2000); // 200ms, 400ms, 600ms... max 2s
        console.log(`[STORE] Redis reconnecting (attempt ${times}), delay ${delay}ms`);
        return delay;
      },
      reconnectOnError(err: Error) {
        // Reconnect on READONLY errors (Azure failover)
        return err.message.includes('READONLY');
      },
    });

    // Connection event logging
    redisClient.on('error', (err) => console.error('[STORE] Redis error:', err.message));
    redisClient.on('connect', () => console.log('[STORE] Redis connected'));
    redisClient.on('ready', () => console.log('[STORE] Redis ready'));
    redisClient.on('close', () => console.warn('[STORE] Redis connection closed'));

    console.log(`[STORE] Redis detected. Initializing RedisConversationStore. TLS: ${url.protocol}`);
    return new RedisConversationStore(redisClient, config.REDIS_TTL);
  }

  console.log('[STORE] REDIS_URL not set. Using InMemoryConversationStore (local LRU).');
  return new InMemoryConversationStore();
}

/**
 * Get the ioredis client instance for health checks.
 * Returns null when using InMemoryStore (REDIS_URL not set).
 * RESIL-02
 */
export function getRedisClient(): Redis | null {
  return redisClient;
}
```

Critical implementation notes:
- `new URL(redisUrl)` validates the URL scheme — `rediss:` protocol means TLS. Non-rediss:// causes process.exit(1).
- `commandTimeout` from config (default 5000ms) — applies to ALL Redis commands.
- `retryStrategy` with exponential backoff — stops after 10 attempts.
- `reconnectOnError` handles Azure failover READONLY errors.
- `getRedisClient()` exported for health check endpoint (Plan 12-02).
- Constructor passes `config.REDIS_TTL` to RedisStore.

---

**server/src/store/index.ts** — REPLACE entirely:

```typescript
import { createConversationStore, getRedisClient } from './factory.js';
import { InMemoryWorkflowStateStore } from './InMemoryWorkflowStateStore.js';

export type { ConversationStore, StoredConversation } from './ConversationStore.js';
export { InMemoryConversationStore } from './InMemoryStore.js';
export { RedisConversationStore } from './RedisStore.js';
export { createConversationStore, getRedisClient } from './factory.js';

export type { WorkflowStateStore } from './WorkflowStateStore.js';
export { InMemoryWorkflowStateStore } from './InMemoryWorkflowStateStore.js';

/**
 * Singleton conversation store — backend selected by factory at module load.
 * REDIS_URL absent → InMemoryConversationStore
 * REDIS_URL set    → RedisConversationStore (full ioredis implementation)
 *
 * STORE-03
 */
export const conversationStore = createConversationStore();

/** Singleton workflow state store — in-memory only (no Redis backing needed for v1.4) */
export const workflowStateStore = new InMemoryWorkflowStateStore();
```

Only change from Phase 11: added `getRedisClient` export from factory.
  </action>
  <verify>
1. Run: `cd /Users/zycroft/Documents/PA/aaae && npm run build 2>&1 | grep -E "TS[0-9]+|error TS" | head -20` — zero TypeScript errors
2. Run: `node -e "process.env.REDIS_URL=''; require('./server/dist/store/index.js')" 2>&1` — should print InMemoryConversationStore log (empty string is falsy)
3. Run: `grep "RedisConversationStore" /Users/zycroft/Documents/PA/aaae/server/src/store/RedisStore.ts | head -3` — shows class declaration
4. Run: `grep "commandTimeout" /Users/zycroft/Documents/PA/aaae/server/src/store/factory.ts` — shows timeout configuration
5. Run: `grep "getRedisClient" /Users/zycroft/Documents/PA/aaae/server/src/store/index.ts` — shows export
  </verify>
  <done>
RedisConversationStore fully implements ConversationStore with ioredis: get/set/delete/listByUser all operational with TTL, sorted-set index, pipeline batching, and Zod deserialization validation. Factory validates rediss:// scheme, creates ioredis client with commandTimeout and retryStrategy, exports getRedisClient for health checks. All compile without errors.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/zycroft/Documents/PA/aaae && npm run build` — zero TypeScript errors across all workspaces
2. Backward compatibility: `node -e "require('./server/dist/store/index.js')" 2>&1` — prints InMemory log (no REDIS_URL = InMemory selected)
3. `grep -r "commandTimeout" /Users/zycroft/Documents/PA/aaae/server/src/store/` — shows timeout configured
4. `grep -r "ZREVRANGEBYSCORE\|zrevrangebyscore" /Users/zycroft/Documents/PA/aaae/server/src/store/` — shows sorted-set query
5. `grep -r "pipeline" /Users/zycroft/Documents/PA/aaae/server/src/store/RedisStore.ts` — shows pipeline usage
6. `grep "getRedisClient" /Users/zycroft/Documents/PA/aaae/server/src/store/factory.ts` — shows health check export
</verification>

<success_criteria>
- ioredis installed as production dependency in server/package.json
- RedisConversationStore implements all 4 ConversationStore methods with ioredis
- Factory validates rediss:// scheme (rejects non-TLS URLs with process.exit)
- Per-key TTL applied on every set() via SET EX
- commandTimeout configured at client level (default 5000ms from config)
- Sorted-set user index: zadd on set, zrem on delete, zrevrangebyscore on listByUser
- listByUser returns up to 50 conversations sorted most-recent-first
- ioredis retryStrategy with exponential backoff and [STORE] logging
- getRedisClient() exported for health check (Plan 12-02)
- npm run build passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-redis-implementation-resilience/12-01-SUMMARY.md` documenting:
- Files created/modified and key decisions
- ioredis version installed
- Serialization approach (sdkConversationRef exclusion)
- Pipeline usage decisions
- Any deviations from the plan
</output>
