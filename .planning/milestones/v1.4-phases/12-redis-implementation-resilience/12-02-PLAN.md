---
phase: 12-redis-implementation-resilience
plan: 02
type: execute
wave: 2
depends_on:
  - 12-01
files_modified:
  - server/src/app.ts
  - server/package.json
  - server/.env.example
  - server/src/store/__tests__/RedisStore.test.ts
autonomous: true
requirements:
  - RESIL-02

must_haves:
  truths:
    - "GET /health reports redis: 'connected' when ioredis status is 'ready', 'disconnected' otherwise, and 'not_configured' when REDIS_URL is absent"
    - "Health endpoint remains unauthenticated (no Bearer token required)"
    - "ioredis-mock installed as devDependency for RedisStore unit tests"
    - "RedisStore.test.ts tests get/set/delete/listByUser with ioredis-mock, including serialization, TTL, sorted-set index, and expired-key filtering"
    - "server/.env.example documents REDIS_URL, REDIS_TTL, and REDIS_TIMEOUT with descriptions"
  artifacts:
    - path: "server/src/app.ts"
      provides: "Updated /health endpoint reporting Redis connectivity"
      contains: "redis"
    - path: "server/src/store/__tests__/RedisStore.test.ts"
      provides: "Unit tests for RedisConversationStore using ioredis-mock"
      exports: []
    - path: "server/.env.example"
      provides: "Redis env var documentation"
      contains: "REDIS_URL"
  key_links:
    - from: "server/src/app.ts"
      to: "server/src/store/factory.ts"
      via: "import getRedisClient for health status"
      pattern: "getRedisClient"
    - from: "server/src/store/__tests__/RedisStore.test.ts"
      to: "server/src/store/RedisStore.ts"
      via: "import RedisConversationStore for testing"
      pattern: "RedisConversationStore"
---

<objective>
Update the /health endpoint to report Redis connectivity status and add comprehensive unit tests for RedisConversationStore using ioredis-mock. Update .env.example with Redis configuration documentation.

Purpose: Completes the Redis resilience requirements by making Redis status observable via the health endpoint, and ensures the RedisStore implementation from Plan 12-01 is tested without requiring a live Redis server.

Output:
- server/src/app.ts (updated — /health reports Redis status)
- server/src/store/__tests__/RedisStore.test.ts (new — ioredis-mock tests)
- server/.env.example (updated — Redis env vars documented)
- server/package.json (updated — ioredis-mock devDependency)
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@server/src/app.ts
@server/src/store/factory.ts
@server/src/store/RedisStore.ts
@server/src/store/index.ts
@server/src/config.ts
@server/.env.example
@.planning/phases/12-redis-implementation-resilience/12-RESEARCH.md
@.planning/phases/12-redis-implementation-resilience/12-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update /health endpoint and install ioredis-mock</name>
  <files>
    server/src/app.ts
    server/package.json
    server/.env.example
  </files>
  <action>
1. Install ioredis-mock as a devDependency:
```bash
cd /Users/zycroft/Documents/PA/aaae/server && npm install -D ioredis-mock
```

2. Update server/src/app.ts — modify the `/health` endpoint to report Redis connectivity status.

Import `getRedisClient` from the store:
```typescript
import { getRedisClient } from './store/index.js';
```

Replace the existing `/health` handler with:
```typescript
app.get('/health', (_req, res) => {
  const redisClient = getRedisClient();

  let redisStatus: 'connected' | 'disconnected' | 'not_configured';
  if (!redisClient) {
    redisStatus = 'not_configured';
  } else {
    // ioredis status values: 'wait', 'reconnecting', 'connecting', 'connect', 'ready', 'close', 'end'
    // Only 'ready' means connected and accepting commands
    redisStatus = redisClient.status === 'ready' ? 'connected' : 'disconnected';
  }

  res.json({
    status: 'ok',
    authRequired: config.AUTH_REQUIRED,
    redis: redisStatus,
  });
});
```

Key points:
- `getRedisClient()` returns null when REDIS_URL is not set (InMemoryStore mode)
- When null: report `not_configured` (InMemory mode — expected in dev)
- When client exists: check `client.status === 'ready'` — only 'ready' means fully connected
- Health endpoint remains unauthenticated (before the `/api` auth middleware)
- Response always includes `redis` field for operator observability

3. Update server/.env.example — add Redis section at the end:
```
# --- Redis (Phase 12+) ---
# Azure Cache for Redis connection URL. Must use rediss:// (TLS) scheme.
# When not set, server uses in-memory store (suitable for local dev).
# Example: rediss://:your-access-key@your-cache.redis.cache.windows.net:6380
REDIS_URL=

# Conversation TTL in seconds (default: 86400 = 24 hours)
REDIS_TTL=86400

# Redis command timeout in milliseconds (default: 5000 = 5 seconds)
REDIS_TIMEOUT=5000
```
  </action>
  <verify>
Run: `cd /Users/zycroft/Documents/PA/aaae && npm run build 2>&1 | grep -E "TS[0-9]+|error TS" | head -10` — zero TypeScript errors.
Run: `grep "ioredis-mock" /Users/zycroft/Documents/PA/aaae/server/package.json` — shows devDependency.
Run: `grep "redis" /Users/zycroft/Documents/PA/aaae/server/src/app.ts` — shows redis status in health endpoint.
Run: `grep "REDIS_URL" /Users/zycroft/Documents/PA/aaae/server/.env.example` — shows Redis env var documentation.
  </verify>
  <done>
Health endpoint reports redis status (connected/disconnected/not_configured). ioredis-mock installed as devDependency. .env.example documents all Redis env vars.
  </done>
</task>

<task type="auto">
  <name>Task 2: RedisStore unit tests with ioredis-mock</name>
  <files>
    server/src/store/__tests__/RedisStore.test.ts
  </files>
  <action>
Create the test file at server/src/store/__tests__/RedisStore.test.ts:

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import Redis from 'ioredis-mock';
import { RedisConversationStore } from '../RedisStore.js';
import type { StoredConversation } from '@copilot-chat/shared';

/**
 * RedisConversationStore unit tests using ioredis-mock.
 * No external Redis server required — runs entirely in-memory.
 */

function makeConversation(overrides: Partial<StoredConversation> = {}): StoredConversation {
  return {
    externalId: 'test-conv-1',
    sdkConversationRef: { fake: 'sdk-object' },
    history: [],
    userId: 'user-alice',
    tenantId: 'tenant-1',
    createdAt: '2026-02-22T10:00:00.000Z',
    updatedAt: '2026-02-22T10:00:00.000Z',
    status: 'active',
    ...overrides,
  };
}

describe('RedisConversationStore', () => {
  let redis: InstanceType<typeof Redis>;
  let store: RedisConversationStore;
  const TTL = 86400; // 24 hours

  beforeEach(() => {
    redis = new Redis();
    store = new RedisConversationStore(redis as any, TTL);
  });

  describe('get()', () => {
    it('returns undefined for non-existent key', async () => {
      const result = await store.get('non-existent');
      expect(result).toBeUndefined();
    });

    it('retrieves a stored conversation', async () => {
      const conv = makeConversation();
      await store.set('conv-1', conv);
      const result = await store.get('conv-1');
      expect(result).toBeDefined();
      expect(result!.externalId).toBe('test-conv-1');
      expect(result!.userId).toBe('user-alice');
      expect(result!.status).toBe('active');
    });

    it('deserializes with Zod validation (applies defaults for missing fields)', async () => {
      // Manually store JSON missing optional fields to verify Zod handles it
      const minimal = {
        externalId: 'minimal-conv',
        history: [],
        userId: 'user-bob',
        tenantId: 'tenant-2',
        createdAt: '2026-02-22T12:00:00.000Z',
        updatedAt: '2026-02-22T12:00:00.000Z',
        status: 'active',
      };
      await redis.set('conv:minimal-1', JSON.stringify(minimal), 'EX', TTL);
      const result = await store.get('minimal-1');
      expect(result).toBeDefined();
      expect(result!.externalId).toBe('minimal-conv');
      // workflowId, currentStep, stepData, metadata should be undefined (optional)
      expect(result!.workflowId).toBeUndefined();
    });
  });

  describe('set()', () => {
    it('stores conversation and is retrievable', async () => {
      const conv = makeConversation({ externalId: 'set-test' });
      await store.set('set-1', conv);
      const result = await store.get('set-1');
      expect(result).toBeDefined();
      expect(result!.externalId).toBe('set-test');
    });

    it('excludes sdkConversationRef from stored JSON', async () => {
      const conv = makeConversation({ sdkConversationRef: { complexObj: true } });
      await store.set('sdk-test', conv);
      const raw = await redis.get('conv:sdk-test');
      expect(raw).toBeDefined();
      const parsed = JSON.parse(raw!);
      expect(parsed.sdkConversationRef).toBeUndefined();
    });

    it('updates sorted-set user index with updatedAt score', async () => {
      const conv = makeConversation({
        userId: 'user-index-test',
        updatedAt: '2026-02-22T15:00:00.000Z',
      });
      await store.set('idx-1', conv);

      // Verify the sorted set has the entry
      const members = await redis.zrevrangebyscore(
        'user:user-index-test:conversations',
        '+inf', '-inf'
      );
      expect(members).toContain('idx-1');
    });

    it('overwrites existing conversation (TTL resets)', async () => {
      const conv1 = makeConversation({ status: 'active' });
      await store.set('overwrite-1', conv1);

      const conv2 = makeConversation({ status: 'completed', updatedAt: '2026-02-22T16:00:00.000Z' });
      await store.set('overwrite-1', conv2);

      const result = await store.get('overwrite-1');
      expect(result!.status).toBe('completed');
    });
  });

  describe('delete()', () => {
    it('removes conversation key', async () => {
      const conv = makeConversation();
      await store.set('del-1', conv);
      await store.delete('del-1');
      const result = await store.get('del-1');
      expect(result).toBeUndefined();
    });

    it('removes entry from user sorted-set index', async () => {
      const conv = makeConversation({ userId: 'user-del-test' });
      await store.set('del-idx-1', conv);
      await store.delete('del-idx-1');

      const members = await redis.zrevrangebyscore(
        'user:user-del-test:conversations',
        '+inf', '-inf'
      );
      expect(members).not.toContain('del-idx-1');
    });

    it('does not throw when deleting non-existent key', async () => {
      await expect(store.delete('non-existent')).resolves.not.toThrow();
    });
  });

  describe('listByUser()', () => {
    it('returns empty array for user with no conversations', async () => {
      const result = await store.listByUser('no-such-user');
      expect(result).toEqual([]);
    });

    it('returns conversations sorted most-recent-first', async () => {
      const conv1 = makeConversation({
        externalId: 'older',
        userId: 'user-sort',
        updatedAt: '2026-02-22T10:00:00.000Z',
      });
      const conv2 = makeConversation({
        externalId: 'newer',
        userId: 'user-sort',
        updatedAt: '2026-02-22T12:00:00.000Z',
      });
      const conv3 = makeConversation({
        externalId: 'newest',
        userId: 'user-sort',
        updatedAt: '2026-02-22T14:00:00.000Z',
      });

      await store.set('sort-1', conv1);
      await store.set('sort-2', conv2);
      await store.set('sort-3', conv3);

      const result = await store.listByUser('user-sort');
      expect(result).toHaveLength(3);
      expect(result[0].externalId).toBe('newest');
      expect(result[1].externalId).toBe('newer');
      expect(result[2].externalId).toBe('older');
    });

    it('returns only conversations for the specified user', async () => {
      const alice = makeConversation({ externalId: 'alice-conv', userId: 'user-alice' });
      const bob = makeConversation({ externalId: 'bob-conv', userId: 'user-bob' });

      await store.set('alice-1', alice);
      await store.set('bob-1', bob);

      const aliceResult = await store.listByUser('user-alice');
      expect(aliceResult).toHaveLength(1);
      expect(aliceResult[0].externalId).toBe('alice-conv');

      const bobResult = await store.listByUser('user-bob');
      expect(bobResult).toHaveLength(1);
      expect(bobResult[0].externalId).toBe('bob-conv');
    });

    it('filters out expired conversation keys gracefully', async () => {
      const conv = makeConversation({ userId: 'user-expire' });
      await store.set('expire-1', conv);

      // Manually delete the conversation key but leave the sorted-set entry
      // (simulates TTL expiry where sorted-set entry orphans)
      await redis.del('conv:expire-1');

      const result = await store.listByUser('user-expire');
      // Should return empty — the ID is in the sorted set but the key is gone
      expect(result).toHaveLength(0);
    });
  });
});
```

Key test design decisions:
- `makeConversation()` factory with sensible defaults — all tests only override what they care about
- ioredis-mock `new Redis()` creates a fresh in-memory instance per test via `beforeEach`
- Cast `redis as any` to satisfy ioredis type compatibility (ioredis-mock matches API but types differ slightly)
- Tests cover: CRUD operations, serialization (sdkConversationRef exclusion), sorted-set index maintenance, most-recent-first ordering, user isolation, and expired-key filtering
- No network calls — all in-memory

Important: The `__tests__` directory needs to be created first.
  </action>
  <verify>
Run: `cd /Users/zycroft/Documents/PA/aaae && npm run build 2>&1 | grep -E "TS[0-9]+|error TS" | head -10` — zero TypeScript errors.
Run: `cd /Users/zycroft/Documents/PA/aaae/server && npx vitest run src/store/__tests__/RedisStore.test.ts 2>&1 | tail -20` — all tests pass.
  </verify>
  <done>
RedisStore.test.ts covers all 4 ConversationStore methods with ioredis-mock: get (retrieval, deserialization, missing keys), set (storage, sdkConversationRef exclusion, index updates, overwrites), delete (key removal, index cleanup, idempotency), listByUser (empty results, sort order, user isolation, expired-key filtering). All tests pass without external Redis.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/zycroft/Documents/PA/aaae && npm run build` — zero TypeScript errors across all workspaces
2. `cd /Users/zycroft/Documents/PA/aaae/server && npx vitest run src/store/__tests__/RedisStore.test.ts` — all tests pass
3. `grep "redis" /Users/zycroft/Documents/PA/aaae/server/src/app.ts` — shows redis status in health response
4. `grep "getRedisClient" /Users/zycroft/Documents/PA/aaae/server/src/app.ts` — shows import
5. `grep "REDIS_URL" /Users/zycroft/Documents/PA/aaae/server/.env.example` — shows Redis env var documentation
6. `grep "ioredis-mock" /Users/zycroft/Documents/PA/aaae/server/package.json` — shows devDependency
</verification>

<success_criteria>
- GET /health returns { status: 'ok', authRequired: boolean, redis: 'connected' | 'disconnected' | 'not_configured' }
- Health endpoint remains unauthenticated (no middleware)
- ioredis-mock installed as devDependency
- RedisStore.test.ts has tests for get, set, delete, and listByUser
- Tests validate sdkConversationRef exclusion from stored JSON
- Tests validate sorted-set index maintenance (add on set, remove on delete)
- Tests validate most-recent-first sort order in listByUser
- Tests validate expired-key filtering in listByUser
- All tests pass with `npx vitest run`
- server/.env.example documents REDIS_URL, REDIS_TTL, REDIS_TIMEOUT
- npm run build passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-redis-implementation-resilience/12-02-SUMMARY.md` documenting:
- Files created/modified and key decisions
- Health endpoint response format
- Test coverage summary
- ioredis-mock behavior notes (any quirks discovered)
- Any deviations from the plan
</output>
