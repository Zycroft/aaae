---
phase: 20-shell-wiring-progress-indicator-transcript
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/components/TranscriptView.tsx
  - client/src/components/MessageBubble.tsx
  - client/src/components/chat.css
  - client/src/hooks/useChatApi.ts
autonomous: true
requirements: [TRANS-01, TRANS-02]

must_haves:
  truths:
    - "Phase divider lines appear between messages where workflowState.currentPhase changes"
    - "Orchestrator status messages (role='assistant', kind='text' with isStatus flag) render as centered muted text without speech bubbles"
    - "TranscriptView accepts an optional workflowState prop and computes per-message phase context for dividers"
    - "Regular user and assistant bubbles are unchanged — dividers only appear at phase transition points"
  artifacts:
    - path: "client/src/components/TranscriptView.tsx"
      provides: "TranscriptView with phase divider logic between consecutive messages"
      exports: ["TranscriptView"]
    - path: "client/src/components/MessageBubble.tsx"
      provides: "MessageBubble handling subKind=orchestratorStatus for centered muted rendering"
      exports: ["MessageBubble"]
    - path: "client/src/components/chat.css"
      provides: "CSS for .phaseDivider, .orchestratorStatus styles"
      contains: ".phaseDivider"
  key_links:
    - from: "client/src/components/TranscriptView.tsx"
      to: "client/src/hooks/useChatApi.ts"
      via: "TranscriptMessage type — subKind field used to detect orchestratorStatus messages"
      pattern: "subKind.*orchestratorStatus"
    - from: "client/src/components/TranscriptView.tsx"
      to: "client/src/components/MessageBubble.tsx"
      via: "passes onCardAction and message prop; divider injected before bubble"
      pattern: "phaseDivider"
---

<objective>
Enhance the transcript to show phase dividers between workflow phases and render orchestrator status messages as centered muted text instead of speech bubbles.

Purpose: Users can visually distinguish workflow phases in the conversation history and see system status messages without them being confused with actual chat content.
Output: Modified TranscriptView.tsx, MessageBubble.tsx, and new CSS classes in chat.css.
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@client/src/components/TranscriptView.tsx
@client/src/components/MessageBubble.tsx
@client/src/hooks/useChatApi.ts
@client/src/components/chat.css
@.planning/phases/19-workflowstate-schema-client-state-foundation/19-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add phase dividers to TranscriptView</name>
  <files>client/src/hooks/useChatApi.ts, client/src/components/TranscriptView.tsx, client/src/components/chat.css</files>
  <action>
    Phase dividers: The TranscriptView must inject a visible divider row between consecutive messages when the workflow phase changes. The phase information is embedded in each TranscriptMessage via a new optional field `workflowPhase?: string` that will be set by the server response (from workflowState.currentPhase at the time of the message). However, since messages are NormalizedMessage objects from the server and don't carry workflowPhase today, the practical approach for Phase 20 is to annotate messages in useChatApi at dispatch time with the current workflowState.currentPhase as a metadata field, OR to track phase changes in TranscriptView by receiving the message list and detecting changes in a `workflowPhase` field on TranscriptMessage.

    The cleanest approach given existing code: extend `TranscriptMessage` type (in useChatApi.ts) to add `workflowPhase?: string`. When dispatching SEND_SUCCESS and CARD_ACTION_SUCCESS, tag each incoming bot message with the current workflowState.currentPhase (if present). TranscriptView then scans adjacent messages and renders a divider when consecutive bot messages have different non-undefined workflowPhase values.

    Step-by-step:

    **In `client/src/hooks/useChatApi.ts`:**
    - Add `workflowPhase?: string` to the `TranscriptMessage` type definition (after `subKind?`)
    - In the `SEND_SUCCESS` case of reducer, for bot messages: attach `workflowPhase: state.workflowState?.currentPhase` to each bot message when mapping
    - In the `CARD_ACTION_SUCCESS` case: same
    - NOTE: The SET_WORKFLOW_STATE action fires AFTER SEND_SUCCESS (per Phase 19 decision), so the phase on state at SEND_SUCCESS time is the PREVIOUS phase. This is correct — the phase divider should appear at the transition point in the transcript, which is the previous phase's value changing to the new phase value. The new phase (from next response) arrives via a subsequent message. This is acceptable behavior for Phase 20.

    Wait — reconsider. The messages appended in SEND_SUCCESS belong to the response for the CURRENT phase. The workflowState from that same response (dispatched after) sets the NEW currentPhase. So tagging bot messages with `state.workflowState?.currentPhase` (the OLD phase before this response) would be wrong.

    Better approach: Tag the bot messages after SEND_SUCCESS with the workflowState that arrived in the same response. Since the reducer processes SEND_SUCCESS and then SET_WORKFLOW_STATE as separate dispatches, tag the messages in the `send()` function in the hook BEFORE dispatching, using `data.workflowState?.currentPhase` from the API response:

    In `useChatApi.ts`, in the `send()` function after `fetchWithRetry`:
    - Pass `currentPhase: data.workflowState?.currentPhase` to SEND_SUCCESS action
    - In reducer SEND_SUCCESS, apply it to bot messages: `{ ...m, workflowPhase: action.currentPhase, status: 'sent' }`

    Do the same for `cardAction()` and its CARD_ACTION_SUCCESS.

    **In `client/src/hooks/useChatApi.ts`:**
    - Update `TranscriptMessage` type: add `workflowPhase?: string`
    - Update `Action` union: `SEND_SUCCESS` and `CARD_ACTION_SUCCESS` get `currentPhase?: string` field
    - Update reducer cases to spread `workflowPhase: action.currentPhase` onto bot messages
    - Update `send()` and `cardAction()` dispatch calls to include `currentPhase: data.workflowState?.currentPhase`

    **In `client/src/components/TranscriptView.tsx`:**
    - Remove the external workflowState prop (not needed — phase info now lives on messages)
    - Add divider detection logic: before rendering each message, check if the PREVIOUS message had a different non-undefined `workflowPhase`. If so, render a `.phaseDivider` element with the new phase name before the message bubble.
    - Implementation: use `messages.map((message, index) => { ... })` and check `index > 0 && messages[index-1].workflowPhase !== message.workflowPhase && message.workflowPhase !== undefined`.
    - Render divider as: `<div className="phaseDivider" role="separator" aria-label={Phase: ${message.workflowPhase}}><span className="phaseDividerLabel">{message.workflowPhase}</span></div>`

    **In `client/src/components/chat.css`** — add after transcript section:

    ```css
    /* ─────────────────────────────────────────────────────────────────────────
       Phase Divider (TRANS-01)
       Horizontal rule with phase label — appears at workflow phase transitions
       ───────────────────────────────────────────────────────────────────────── */

    .phaseDivider {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) 0;
      color: var(--color-text-muted);
      font-size: var(--font-size-xs);
    }

    .phaseDivider::before,
    .phaseDivider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--color-border);
    }

    .phaseDividerLabel {
      white-space: nowrap;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    ```

    After changes: run `cd /Users/zycroft/Documents/PA/aaae && npm run build` to verify no TypeScript errors.
  </action>
  <verify>Run `cd /Users/zycroft/Documents/PA/aaae && npm run build 2>&1`. Zero TypeScript errors. Grep for `workflowPhase` in TranscriptView.tsx and useChatApi.ts to confirm field is set and consumed. Grep for `.phaseDivider` in chat.css to confirm styles exist.</verify>
  <done>TranscriptView renders `.phaseDivider` elements between messages where workflowPhase transitions. useChatApi tags bot messages with currentPhase from API response. TypeScript clean. Committed `feat(20-02): add workflow phase dividers to TranscriptView`.</done>
</task>

<task type="auto">
  <name>Task 2: Orchestrator status message rendering in MessageBubble</name>
  <files>client/src/hooks/useChatApi.ts, client/src/components/MessageBubble.tsx, client/src/components/chat.css</files>
  <action>
    Orchestrator status messages should render as centered, muted text without speech bubbles — visually distinct from user/assistant messages. These are messages where `subKind === 'orchestratorStatus'`.

    **In `client/src/hooks/useChatApi.ts`:**
    - Add `'orchestratorStatus'` to the `subKind` union type: `subKind?: 'cardSubmit' | 'orchestratorStatus'`
    - The server normalizer (v1.5) may return messages with a flag to indicate system/orchestrator messages. For Phase 20, treat messages from the server where `role === 'assistant'` and `kind === 'text'` as potentially orchestrator messages if the text starts with a system-style prefix (e.g., "[System]" or similar). However, since we have no server-side subKind field yet, the simpler approach is: leave subKind detection to the server to send in a future phase. For Phase 20, implement the rendering path for `subKind === 'orchestratorStatus'` in MessageBubble so it's ready when server adds it.
    - The TranscriptMessage type already allows `subKind?: 'cardSubmit'` — extend to `subKind?: 'cardSubmit' | 'orchestratorStatus'` (this is in useChatApi.ts from Task 1 or now).

    **In `client/src/components/MessageBubble.tsx`:**
    - Add early return for `message.subKind === 'orchestratorStatus'`:
    ```tsx
    if (message.subKind === 'orchestratorStatus') {
      return (
        <div className="orchestratorStatus" role="status">
          <span>{message.text}</span>
        </div>
      );
    }
    ```
    - This renders before the main bubble logic so it bypasses avatar + bubble structure entirely.

    **In `client/src/components/chat.css`** — add after phase divider section:

    ```css
    /* ─────────────────────────────────────────────────────────────────────────
       Orchestrator Status Messages (TRANS-02)
       Centered, muted — no speech bubble or avatar.
       ───────────────────────────────────────────────────────────────────────── */

    .orchestratorStatus {
      text-align: center;
      color: var(--color-text-muted);
      font-size: var(--font-size-sm);
      font-style: italic;
      padding: var(--space-1) var(--space-4);
      user-select: none;
    }
    ```

    After changes: run `cd /Users/zycroft/Documents/PA/aaae && npm run build` to verify no TypeScript errors.
  </action>
  <verify>Run `cd /Users/zycroft/Documents/PA/aaae && npm run build 2>&1`. Zero TypeScript errors. Grep for `orchestratorStatus` in MessageBubble.tsx, useChatApi.ts, and chat.css to confirm all three locations updated. Grep for the early-return pattern in MessageBubble.tsx.</verify>
  <done>MessageBubble renders orchestratorStatus messages as centered muted text. subKind type extended. CSS class .orchestratorStatus added. TypeScript clean. Committed `feat(20-02): render orchestrator status messages as centered muted text`.</done>
</task>

</tasks>

<verification>
1. Run `cd /Users/zycroft/Documents/PA/aaae && npm run build` — no TypeScript errors
2. `TranscriptView.tsx` maps over messages with index, checks `messages[index-1].workflowPhase !== message.workflowPhase` to inject divider
3. `useChatApi.ts` `TranscriptMessage` type has `workflowPhase?: string` and `subKind?: 'cardSubmit' | 'orchestratorStatus'`
4. `MessageBubble.tsx` early-returns `.orchestratorStatus` div for subKind === 'orchestratorStatus'
5. `chat.css` contains `.phaseDivider`, `.phaseDividerLabel`, `.orchestratorStatus` classes
</verification>

<success_criteria>
- TranscriptView injects `.phaseDivider` elements between messages where workflowPhase changes
- MessageBubble renders subKind=orchestratorStatus as centered italic text without bubble or avatar
- useChatApi tags bot messages with currentPhase from API response at dispatch time
- All changes TypeScript-clean, build passes
- No regression to existing text/card bubble rendering (bubbles unchanged when subKind is absent)
</success_criteria>

<output>
After completion, create `.planning/phases/20-shell-wiring-progress-indicator-transcript/20-02-SUMMARY.md`
</output>
