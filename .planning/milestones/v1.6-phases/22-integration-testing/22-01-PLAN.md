---
phase: 22-integration-testing
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - client/src/components/WorkflowIntegration.test.tsx
autonomous: true
requirements: [TEST-04]

must_haves:
  truths:
    - "Integration test drives a simulated multi-step workflow through at least 2 phase transitions (idle -> phase 1 -> phase 2 -> completed)"
    - "Test exercises at least 2 different input modes (choice pills in phase 1, confirmation Yes/No in phase 2)"
    - "Test verifies resetConversation clears all state — no workflow artifacts visible after reset"
    - "All 19 existing client unit tests continue to pass alongside the new integration test"
  artifacts:
    - path: "client/src/components/WorkflowIntegration.test.tsx"
      provides: "Integration test simulating full workflow lifecycle"
      contains: "phase transition"
  key_links:
    - from: "client/src/components/WorkflowIntegration.test.tsx"
      to: "client/src/hooks/useChatApi.ts"
      via: "Tests the reducer logic (initialState, SEND_SUCCESS, SET_WORKFLOW_STATE, RESET_CONVERSATION actions)"
      pattern: "reducer|SET_WORKFLOW_STATE|RESET_CONVERSATION"
    - from: "client/src/components/WorkflowIntegration.test.tsx"
      to: "client/src/components/WorkflowProgress.tsx"
      via: "renderToStaticMarkup to verify progress bar rendering at each phase"
      pattern: "WorkflowProgress"
    - from: "client/src/components/WorkflowIntegration.test.tsx"
      to: "client/src/components/ChatInput.tsx"
      via: "renderToStaticMarkup to verify input mode rendering at each phase"
      pattern: "ChatInput"
    - from: "client/src/components/WorkflowIntegration.test.tsx"
      to: "client/src/components/WorkflowComplete.tsx"
      via: "renderToStaticMarkup to verify completion view rendering"
      pattern: "WorkflowComplete"
---

<objective>
Write an integration test that simulates a complete multi-step workflow lifecycle from start to finish, verifying that phase transitions, input mode changes, completion rendering, and state reset all work correctly in sequence.

Purpose: Validates the assembled v1.6 system end-to-end — ensuring all components (WorkflowProgress, ChatInput, WorkflowComplete, TranscriptView) render the correct UI for each workflow state, and that resetConversation returns to clean initial state.
Output: WorkflowIntegration.test.tsx with comprehensive lifecycle assertions.
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@client/src/hooks/useChatApi.ts
@client/src/components/WorkflowProgress.tsx
@client/src/components/ChatInput.tsx
@client/src/components/WorkflowComplete.tsx
@client/src/components/TranscriptView.tsx
@client/src/components/MetadataPane.tsx
@shared/src/schemas/workflowState.ts
@client/src/components/WorkflowProgress.test.tsx
@client/jest.config.cjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write integration test for full workflow lifecycle</name>
  <files>client/src/components/WorkflowIntegration.test.tsx</files>
  <action>
    Create `client/src/components/WorkflowIntegration.test.tsx`.

    **Approach:** Since ChatShell depends on MSAL (`useMsal`, `msalInstance`) which requires complex mocking, the integration test exercises the system at two complementary levels:

    1. **Reducer-level**: Import the reducer and initialState from `useChatApi.ts` to directly test state transitions. The reducer is NOT currently exported, so you MUST first add `export` to the `reducer` function and `export { initialState }` in `client/src/hooks/useChatApi.ts`. Add `export` keyword to:
       - `export const initialState: State = { ... }`
       - `export function reducer(state: State, action: Action): State { ... }`
       Also export the `State` and `Action` types.

    2. **Component rendering**: Use `renderToStaticMarkup` from `react-dom/server` to verify each component renders correctly for a given workflow state at each step of the lifecycle.

    **Test structure — use `describe('Workflow Integration', () => { ... })` with nested describes:**

    ```
    describe('Workflow Integration', () => {
      describe('full lifecycle: idle -> active(choice) -> active(confirmation) -> completed -> reset', () => {

        // Define workflow state fixtures for each phase:
        const phase1State: WorkflowState = {
          step: 'gather-info',
          turnCount: 1,
          status: 'active',
          currentPhase: 'Gathering Information',
          progress: 0.25,
          suggestedInputType: 'choice',
          choices: ['Option A', 'Option B', 'Option C'],
        };

        const phase2State: WorkflowState = {
          step: 'confirm-details',
          turnCount: 3,
          status: 'active',
          currentPhase: 'Confirming Details',
          progress: 0.75,
          suggestedInputType: 'confirmation',
        };

        const completedState: WorkflowState = {
          step: 'done',
          turnCount: 5,
          status: 'completed',
          currentPhase: 'Complete',
          progress: 1,
          collectedData: { first_name: 'Alice', preference: 'Option A', confirmed: 'Yes' },
        };

        test('Step 1: idle state — no workflow artifacts visible', () => {
          // Reducer: initialState has workflowState = null
          expect(initialState.workflowState).toBeNull();
          expect(initialState.messages).toEqual([]);

          // WorkflowProgress renders nothing when workflowState is null
          const progressHtml = renderToStaticMarkup(<WorkflowProgress workflowState={null} />);
          expect(progressHtml).toBe('');

          // ChatInput in default mode — no choice pills, no confirmation buttons
          const inputHtml = renderToStaticMarkup(
            <ChatInput onSend={() => {}} disabled={false} />
          );
          expect(inputHtml).not.toContain('choicePill');
          expect(inputHtml).not.toContain('inputDisabledStatus');
        });

        test('Step 2: transition to phase 1 (active + choice mode)', () => {
          // Reducer: dispatch SET_WORKFLOW_STATE
          let state = reducer(initialState, {
            type: 'INIT_CONVERSATION',
            conversationId: 'test-conv-123',
          });
          // Simulate bot response with phase 1 workflow state
          state = reducer(state, {
            type: 'SEND_SUCCESS',
            optimisticId: 'msg-1',
            botMessages: [{ id: 'bot-1', role: 'assistant', kind: 'text', text: 'Please choose an option.' }],
            currentPhase: 'Gathering Information',
          });
          state = reducer(state, {
            type: 'SET_WORKFLOW_STATE',
            workflowState: phase1State,
          });

          // Verify state
          expect(state.workflowState).toEqual(phase1State);
          expect(state.workflowState?.status).toBe('active');
          expect(state.workflowState?.suggestedInputType).toBe('choice');
          expect(state.messages).toHaveLength(1); // bot message (optimistic not found since id mismatch is expected)

          // WorkflowProgress shows phase label and determinate bar
          const progressHtml = renderToStaticMarkup(<WorkflowProgress workflowState={phase1State} />);
          expect(progressHtml).toContain('Gathering Information');
          expect(progressHtml).toContain('width:25%');
          expect(progressHtml).not.toContain('indeterminate');

          // ChatInput shows choice pills
          const inputHtml = renderToStaticMarkup(
            <ChatInput onSend={() => {}} disabled={false} suggestedInputType="choice" choices={phase1State.choices} />
          );
          expect(inputHtml).toContain('choicePill');
          expect(inputHtml).toContain('Option A');
          expect(inputHtml).toContain('Option B');
          expect(inputHtml).toContain('Option C');
          // Free-text textarea still available (INPUT-04)
          expect(inputHtml).toContain('chatTextarea');
        });

        test('Step 3: transition to phase 2 (active + confirmation mode)', () => {
          // Reducer: apply phase 2 state
          let state = reducer(initialState, {
            type: 'INIT_CONVERSATION',
            conversationId: 'test-conv-123',
          });
          state = reducer(state, {
            type: 'SET_WORKFLOW_STATE',
            workflowState: phase2State,
          });

          expect(state.workflowState).toEqual(phase2State);
          expect(state.workflowState?.suggestedInputType).toBe('confirmation');
          expect(state.workflowState?.currentPhase).toBe('Confirming Details');

          // WorkflowProgress shows updated phase and progress
          const progressHtml = renderToStaticMarkup(<WorkflowProgress workflowState={phase2State} />);
          expect(progressHtml).toContain('Confirming Details');
          expect(progressHtml).toContain('width:75%');

          // ChatInput shows Yes/No confirmation buttons
          const inputHtml = renderToStaticMarkup(
            <ChatInput onSend={() => {}} disabled={false} suggestedInputType="confirmation" />
          );
          expect(inputHtml).toContain('choicePillPrimary');
          expect(inputHtml).toContain('>Yes<');
          expect(inputHtml).toContain('>No<');
          // Free-text textarea still available (INPUT-04)
          expect(inputHtml).toContain('chatTextarea');
        });

        test('Step 4: transition to completed state', () => {
          // Reducer: apply completed state
          let state = reducer(initialState, {
            type: 'INIT_CONVERSATION',
            conversationId: 'test-conv-123',
          });
          state = reducer(state, {
            type: 'SET_WORKFLOW_STATE',
            workflowState: completedState,
          });

          expect(state.workflowState?.status).toBe('completed');

          // WorkflowProgress should NOT render for completed status
          const progressHtml = renderToStaticMarkup(<WorkflowProgress workflowState={completedState} />);
          expect(progressHtml).toBe('');

          // WorkflowComplete should render with collected data
          const completeHtml = renderToStaticMarkup(
            <WorkflowComplete workflowState={completedState} onReset={() => {}} />
          );
          expect(completeHtml).toContain('Workflow Complete');
          expect(completeHtml).toContain('First name');   // formatLabel('first_name')
          expect(completeHtml).toContain('Alice');
          expect(completeHtml).toContain('Preference');    // formatLabel('preference')
          expect(completeHtml).toContain('Option A');
          expect(completeHtml).toContain('Start new conversation');
          expect(completeHtml).toContain('Download summary');
        });

        test('Step 5: reset returns to initial idle state', () => {
          // Build up state then reset
          let state = reducer(initialState, {
            type: 'INIT_CONVERSATION',
            conversationId: 'test-conv-123',
          });
          state = reducer(state, {
            type: 'ADD_OPTIMISTIC_MESSAGE',
            message: { id: 'u-1', role: 'user', kind: 'text', text: 'Hello' },
          });
          state = reducer(state, {
            type: 'SET_WORKFLOW_STATE',
            workflowState: completedState,
          });

          // Verify state has data
          expect(state.conversationId).toBe('test-conv-123');
          expect(state.messages).toHaveLength(1);
          expect(state.workflowState).toBeTruthy();

          // Reset
          state = reducer(state, { type: 'RESET_CONVERSATION' });

          // All state cleared
          expect(state.conversationId).toBeNull();
          expect(state.messages).toEqual([]);
          expect(state.workflowState).toBeNull();
          expect(state.isLoading).toBe(false);
          expect(state.error).toBeNull();

          // Components render clean after reset
          const progressHtml = renderToStaticMarkup(<WorkflowProgress workflowState={null} />);
          expect(progressHtml).toBe('');

          const inputHtml = renderToStaticMarkup(
            <ChatInput onSend={() => {}} disabled={false} />
          );
          expect(inputHtml).not.toContain('choicePill');
          expect(inputHtml).not.toContain('inputDisabledStatus');
          expect(inputHtml).toContain('chatTextarea');
        });
      });

      describe('phase dividers in transcript messages', () => {
        test('messages carry workflowPhase from SEND_SUCCESS currentPhase', () => {
          let state = reducer(initialState, {
            type: 'INIT_CONVERSATION',
            conversationId: 'test-conv-123',
          });

          // Phase 1 message
          state = reducer(state, {
            type: 'SEND_SUCCESS',
            optimisticId: 'opt-1',
            botMessages: [{ id: 'b1', role: 'assistant', kind: 'text', text: 'Phase 1 response' }],
            currentPhase: 'Gathering Information',
          });

          // Phase 2 message
          state = reducer(state, {
            type: 'SEND_SUCCESS',
            optimisticId: 'opt-2',
            botMessages: [{ id: 'b2', role: 'assistant', kind: 'text', text: 'Phase 2 response' }],
            currentPhase: 'Confirming Details',
          });

          // First bot message tagged with phase 1
          const botMsg1 = state.messages.find(m => m.id === 'b1');
          expect(botMsg1?.workflowPhase).toBe('Gathering Information');

          // Second bot message tagged with phase 2
          const botMsg2 = state.messages.find(m => m.id === 'b2');
          expect(botMsg2?.workflowPhase).toBe('Confirming Details');

          // Different phases on consecutive messages = divider should appear
          expect(botMsg1?.workflowPhase).not.toBe(botMsg2?.workflowPhase);
        });
      });

      describe('error state', () => {
        test('workflow error state is tracked in reducer', () => {
          const errorState: WorkflowState = {
            step: 'failed',
            turnCount: 3,
            status: 'error',
            currentPhase: 'Error',
            progress: 0.5,
          };

          let state = reducer(initialState, {
            type: 'INIT_CONVERSATION',
            conversationId: 'test-conv-123',
          });
          state = reducer(state, {
            type: 'SET_WORKFLOW_STATE',
            workflowState: errorState,
          });

          expect(state.workflowState?.status).toBe('error');

          // WorkflowProgress does NOT render for error status (handled by ChatShell)
          const progressHtml = renderToStaticMarkup(<WorkflowProgress workflowState={errorState} />);
          expect(progressHtml).toBe('');
        });
      });
    });
    ```

    **IMPORTANT implementation steps:**

    1. First, edit `client/src/hooks/useChatApi.ts` to export `reducer`, `initialState`, `State`, and `Action`:
       - Change `const initialState: State` to `export const initialState: State`
       - Change `function reducer(state: State, action: Action): State` to `export function reducer(state: State, action: Action): State`
       - Add `export` to the `State` type: `export type State = { ... }`
       - Add `export` to the `Action` type: `export type Action = ...`

    2. Then create the test file with `/* global describe, test, expect */` at the top (required for Jest globals in ESLint v9 flat config).

    3. Run `cd /Users/zycroft/Documents/PA/aaae/client && npm test` to verify all tests pass (both existing 19 tests + new integration tests).

    4. Run `cd /Users/zycroft/Documents/PA/aaae && npm run build` to verify TypeScript build is clean.

    5. Commit with message: `feat(22-01): add workflow integration test with full lifecycle simulation`
  </action>
  <verify>
    Run `cd /Users/zycroft/Documents/PA/aaae/client && npm test 2>&1`. All tests pass (existing 19 + new integration tests).
    Run `cd /Users/zycroft/Documents/PA/aaae && npm run build 2>&1`. TypeScript build clean.
  </verify>
  <done>
    WorkflowIntegration.test.tsx exists with tests covering: idle state, phase 1 (choice mode), phase 2 (confirmation mode), completed state, reset to idle, phase dividers in transcript, and error state. All tests pass alongside existing 19 unit tests. Build clean.
  </done>
</task>

</tasks>

<verification>
1. Run `cd /Users/zycroft/Documents/PA/aaae/client && npm test` — all tests pass (19 existing + new integration tests)
2. Run `cd /Users/zycroft/Documents/PA/aaae && npm run build` — no TypeScript errors
3. Integration test exercises 2+ phase transitions: idle -> Gathering Information -> Confirming Details -> Completed
4. Integration test exercises 2+ input modes: choice (pills) and confirmation (Yes/No)
5. Integration test verifies resetConversation clears all state to initial values
6. Integration test verifies component rendering at each lifecycle step via renderToStaticMarkup
7. `useChatApi.ts` exports `reducer`, `initialState`, `State`, `Action` without breaking existing consumers
</verification>

<success_criteria>
- WorkflowIntegration.test.tsx exists in client/src/components/
- Integration test covers full lifecycle: idle -> active(choice) -> active(confirmation) -> completed -> reset -> idle
- At least 2 phase transitions verified (Gathering Information -> Confirming Details)
- At least 2 input modes verified (choice pills, confirmation Yes/No)
- resetConversation verified to clear all state (conversationId, messages, workflowState, isLoading, error)
- Phase divider mechanics verified (workflowPhase tags on messages)
- Error state verified (status='error' tracked, WorkflowProgress does not render)
- All existing tests continue to pass
- TypeScript build clean
</success_criteria>

<output>
After completion, create `.planning/phases/22-integration-testing/22-01-SUMMARY.md`
</output>
