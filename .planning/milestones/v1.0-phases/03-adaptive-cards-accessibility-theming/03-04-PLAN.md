---
phase: 03-adaptive-cards-accessibility-theming
plan: 04
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - client/package.json
  - client/src/components/AdaptiveCardMessage.tsx
  - client/src/components/MessageBubble.tsx
  - client/src/api/chatApi.ts
  - client/src/hooks/useChatApi.ts
  - client/src/components/chat.css
autonomous: true
requirements: [UI-06, UI-07, UI-08, UI-10]

must_haves:
  truths:
    - "An Adaptive Card from a bot message renders as interactive HTML in the transcript (not a placeholder)"
    - "Clicking Submit on a card fires exactly one POST to /api/chat/card-action then disables the card"
    - "The card cannot be submitted a second time — the submit button is disabled/overlaid after first click"
    - "A submitted card's userSummary appears as a distinct chip in the transcript (UI-10)"
    - "TypeScript compiles clean across client workspace"
  artifacts:
    - path: "client/src/components/AdaptiveCardMessage.tsx"
      provides: "Adaptive Card renderer using adaptivecards SDK v3 with useRef/useEffect pattern"
      exports: ["AdaptiveCardMessage"]
    - path: "client/src/api/chatApi.ts"
      provides: "sendCardAction() fetch wrapper for /api/chat/card-action"
      exports: ["sendCardAction"]
    - path: "client/src/hooks/useChatApi.ts"
      provides: "cardAction() function wired into the hook return; CARD_ACTION_SUCCESS reducer action"
      exports: ["useChatApi"]
    - path: "client/src/components/MessageBubble.tsx"
      provides: "Renders AdaptiveCardMessage for kind='adaptiveCard'; renders cardSubmit chip for UI-10"
      contains: "AdaptiveCardMessage"
  key_links:
    - from: "client/src/components/AdaptiveCardMessage.tsx"
      to: "/api/chat/card-action"
      via: "onCardAction callback → useChatApi.cardAction() → chatApi.sendCardAction()"
      pattern: "onCardAction"
    - from: "client/src/components/MessageBubble.tsx"
      to: "client/src/components/AdaptiveCardMessage.tsx"
      via: "import and render for kind='adaptiveCard'"
      pattern: "AdaptiveCardMessage"
    - from: "client/src/hooks/useChatApi.ts"
      to: "client/src/api/chatApi.ts"
      via: "sendCardAction() import"
      pattern: "sendCardAction"
---

<objective>
Install the `adaptivecards` SDK, implement AdaptiveCardMessage component with the useRef/useEffect rendering pattern, add the cardAction hook function, and wire card submissions through the existing useChatApi state machine. Submitted card shows a distinct UI-10 chip.

Purpose: UI-06 (card rendering via SDK), UI-07 (card action submission to /api/chat/card-action), UI-08 (card disabled after first submit), UI-10 (card-submit chip in transcript).
Output: AdaptiveCardMessage.tsx, sendCardAction() in chatApi.ts, cardAction() in useChatApi.ts, MessageBubble updated.
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-adaptive-cards-accessibility-theming/03-CONTEXT.md
@.planning/phases/03-adaptive-cards-accessibility-theming/03-RESEARCH.md
@.planning/phases/02-text-chat-end-to-end/02-03-SUMMARY.md
@.planning/phases/02-text-chat-end-to-end/02-04-SUMMARY.md
@.planning/phases/03-adaptive-cards-accessibility-theming/03-01-SUMMARY.md
@client/src/components/MessageBubble.tsx
@client/src/hooks/useChatApi.ts
@client/src/api/chatApi.ts
@client/src/components/chat.css
@shared/src/schemas/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install adaptivecards + implement AdaptiveCardMessage component</name>
  <files>
    client/package.json
    client/src/components/AdaptiveCardMessage.tsx
    client/src/components/chat.css
  </files>
  <action>
    **Install the package:**
    ```bash
    npm install adaptivecards --workspace=client
    ```

    Verify installation: `npm list adaptivecards --workspace=client` — must show a version.

    **IMPORTANT: Verify the actual API before coding.** Run:
    ```bash
    node -e "const AC = require('./client/node_modules/adaptivecards/dist/adaptivecards.js'); console.log(Object.keys(AC).filter(k => k.includes('Card') || k.includes('Action')).join('\n'))"
    ```
    Or read `client/node_modules/adaptivecards/dist/adaptivecards.d.ts` to confirm:
    - Constructor: `new AdaptiveCards.AdaptiveCard()`
    - Parse: `ac.parse(json)`
    - Render: `ac.render()` returns `HTMLElement | undefined`
    - Action callback: `ac.onExecuteAction = (action: AdaptiveCards.Action) => void`
    - Action type name: `action.getJsonTypeName()` returns e.g. `"Action.Submit"`
    - Submit data: `(action as AdaptiveCards.SubmitAction).data` — type `object | undefined`

    Adapt the implementation below if the actual API differs.

    **Create `client/src/components/AdaptiveCardMessage.tsx`:**

    ```tsx
    import { useRef, useEffect, useState } from 'react';
    import * as AdaptiveCards from 'adaptivecards';
    import type { TranscriptMessage } from '../hooks/useChatApi.js';

    interface AdaptiveCardMessageProps {
      message: TranscriptMessage; // kind === 'adaptiveCard'
      onCardAction: (
        cardId: string,
        userSummary: string,
        submitData: Record<string, unknown>
      ) => void;
    }

    export function AdaptiveCardMessage({ message, onCardAction }: AdaptiveCardMessageProps) {
      const containerRef = useRef<HTMLDivElement>(null);
      const submittedRef = useRef(false); // use ref (not state) to prevent stale closure on first click
      const [submitted, setSubmitted] = useState(false);

      useEffect(() => {
        if (!containerRef.current || !message.cardJson) return;

        const ac = new AdaptiveCards.AdaptiveCard();
        ac.hostConfig = new AdaptiveCards.HostConfig({
          fontFamily: 'system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif',
        });

        ac.onExecuteAction = (action) => {
          // Guard: ignore if already submitted
          if (submittedRef.current) return;
          submittedRef.current = true;
          setSubmitted(true);

          const submitData: Record<string, unknown> = {
            action: action.getJsonTypeName(),
          };

          if (action.getJsonTypeName() === 'Action.Submit') {
            const submitAction = action as AdaptiveCards.SubmitAction;
            const data = submitAction.data;
            if (data && typeof data === 'object') {
              Object.assign(submitData, data);
            }
          } else if (action.getJsonTypeName() === 'Action.OpenUrl') {
            const openUrlAction = action as AdaptiveCards.OpenUrlAction;
            submitData.url = openUrlAction.url;
          }

          // Derive userSummary from card title or cardId
          const cardTitle =
            (message.cardJson as { title?: string })?.title ??
            (message.cardJson as { body?: Array<{ type: string; text?: string }> })?.body?.find(
              (el) => el.type === 'TextBlock'
            )?.text ??
            `Card ${message.cardId ?? 'unknown'}`;

          onCardAction(message.cardId ?? '', `Submitted: ${cardTitle}`, submitData);
        };

        try {
          ac.parse(message.cardJson);
          const rendered = ac.render();
          if (rendered && containerRef.current) {
            containerRef.current.innerHTML = '';
            containerRef.current.appendChild(rendered);
          }
        } catch (err) {
          console.error('[AdaptiveCardMessage] Failed to render card:', err);
          if (containerRef.current) {
            containerRef.current.innerHTML = '<p class="cardRenderError">Card failed to render.</p>';
          }
        }

        return () => {
          if (containerRef.current) {
            containerRef.current.innerHTML = '';
          }
        };
      }, [message.cardJson, message.cardId]);

      return (
        <div className={`adaptiveCardWrapper${submitted ? ' submitted' : ''}`}>
          {submitted && (
            <div className="cardPendingOverlay" aria-live="polite">
              Submitting…
            </div>
          )}
          <div
            ref={containerRef}
            className="adaptiveCardContainer"
            aria-label="Interactive card"
          />
        </div>
      );
    }
    ```

    **Add styles to `client/src/components/chat.css`:**
    ```css
    /* ─────────────────────────────────────────────────────────────────────────────
       Adaptive Cards (UI-06, UI-07, UI-08)
       ───────────────────────────────────────────────────────────────────────────── */

    .adaptiveCardWrapper {
      position: relative;
      max-width: min(90%, 520px);
      border: 1px solid var(--color-card-border);
      border-radius: 8px;
      background: var(--color-card-surface);
      overflow: hidden;
      overflow-x: auto; /* 360px overflow handling */
    }

    .adaptiveCardWrapper.submitted {
      pointer-events: none;
      opacity: 0.6;
    }

    .cardPendingOverlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.15);
      font-size: var(--font-size-sm);
      color: var(--color-text);
      z-index: 1;
    }

    .adaptiveCardContainer {
      padding: var(--space-3);
    }

    .cardRenderError {
      color: var(--color-error-text);
      font-size: var(--font-size-sm);
      padding: var(--space-3);
      margin: 0;
    }

    /* Card submit chip (UI-10) */
    .cardSubmitChip {
      display: inline-block;
      padding: var(--space-1) var(--space-3);
      background: var(--color-surface);
      border: 1px solid var(--color-border);
      border-radius: 16px;
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
      font-style: italic;
      max-width: min(70%, 420px);
      word-break: break-word;
    }
    ```

    Run `cd client && npx tsc --noEmit` — must exit 0.
  </action>
  <verify>
    npm list adaptivecards --workspace=client
    ls client/src/components/AdaptiveCardMessage.tsx
    cd client && npx tsc --noEmit
    grep "adaptiveCardWrapper" client/src/components/chat.css
  </verify>
  <done>
    adaptivecards package is installed in client workspace.
    AdaptiveCardMessage.tsx exists with useRef/useEffect rendering pattern.
    Component has submitted guard (ref + state), onExecuteAction handler, error catch.
    CSS has .adaptiveCardWrapper, .submitted, .cardPendingOverlay, .cardSubmitChip classes.
    TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add sendCardAction to chatApi + cardAction to useChatApi + update MessageBubble</name>
  <files>
    client/src/api/chatApi.ts
    client/src/hooks/useChatApi.ts
    client/src/components/MessageBubble.tsx
  </files>
  <action>
    **Add `sendCardAction` to `client/src/api/chatApi.ts`:**

    Append after `sendMessage`:
    ```ts
    export async function sendCardAction(
      conversationId: string,
      cardId: string,
      userSummary: string,
      submitData: Record<string, unknown>,
      signal?: AbortSignal,
    ): Promise<{ conversationId: string; messages: NormalizedMessage[] }> {
      const response = await fetch('/api/chat/card-action', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ conversationId, cardId, userSummary, submitData }),
        signal,
      });
      if (!response.ok) {
        throw Object.assign(new Error(`HTTP ${response.status}`), { status: response.status });
      }
      return response.json() as Promise<{ conversationId: string; messages: NormalizedMessage[] }>;
    }
    ```

    **Update `client/src/hooks/useChatApi.ts`:**

    1. Add import: `import { startConversation, sendMessage, sendCardAction } from '../api/chatApi.js';`

    2. Add `subKind?: 'cardSubmit'` to `TranscriptMessage` type extension.

    3. Add reducer action: `| { type: 'CARD_ACTION_SUCCESS'; optimisticId: string; botMessages: NormalizedMessage[] }`
       Handle it identically to `SEND_SUCCESS` (mark optimistic as sent, append bot messages).

    4. Add `cardAction` function to the hook (after `send`):
    ```ts
    async function cardAction(
      cardId: string,
      userSummary: string,
      submitData: Record<string, unknown>,
    ): Promise<void> {
      if (!state.conversationId) return;

      const optimisticId = crypto.randomUUID();
      const optimisticMessage: TranscriptMessage = {
        id: optimisticId,
        role: 'user',
        kind: 'text',
        text: userSummary,
        status: 'sending',
        subKind: 'cardSubmit', // UI-10: distinguishes chip from regular text
      };

      dispatch({ type: 'ADD_OPTIMISTIC_MESSAGE', message: optimisticMessage });

      const skeletonTimer = setTimeout(() => {
        dispatch({ type: 'START_LOADING' });
      }, 300);

      const controller = new AbortController();
      abortRef.current = controller;

      try {
        const data = await fetchWithRetry(
          (signal) => sendCardAction(state.conversationId!, cardId, userSummary, submitData, signal),
          controller.signal,
        );
        clearTimeout(skeletonTimer);
        dispatch({ type: 'CARD_ACTION_SUCCESS', optimisticId, botMessages: data.messages });
      } catch (err) {
        clearTimeout(skeletonTimer);
        const error = err as Error;
        if (error.name !== 'AbortError') {
          dispatch({ type: 'SEND_ERROR', optimisticId, errorMessage: error.message || 'Card action failed.' });
        }
      }
    }
    ```

    5. Add `cardAction` to the hook return: `return { ..., cardAction };`

    **Update `client/src/components/MessageBubble.tsx`:**

    1. Import `AdaptiveCardMessage`.
    2. Add `onCardAction` prop to `MessageBubbleProps`:
       ```ts
       interface MessageBubbleProps {
         message: TranscriptMessage;
         onCardAction: (cardId: string, userSummary: string, submitData: Record<string, unknown>) => void;
       }
       ```
    3. Replace the `kind === 'adaptiveCard'` placeholder with `<AdaptiveCardMessage message={message} onCardAction={onCardAction} />`
    4. For `kind === 'text'` with `message.subKind === 'cardSubmit'`: render `<span className="cardSubmitChip">{message.text}</span>` instead of the regular `<span>`.

    **Update `client/src/components/TranscriptView.tsx`:**
    - Import and pass `cardAction` from `useChatApi` down to `MessageBubble` via a prop.
    - TranscriptView receives `onCardAction` prop and passes it to each `<MessageBubble>`.

    **Update `client/src/components/ChatShell.tsx`:**
    - Destructure `cardAction` from `useChatApi()`.
    - Pass `onCardAction={cardAction}` to `<TranscriptView>`.

    Run `cd client && npx tsc --noEmit` — must exit 0.
    Run `npm test` — must exit 0 (no regressions).
  </action>
  <verify>
    cd client && npx tsc --noEmit
    npm test
    grep "sendCardAction" client/src/api/chatApi.ts
    grep "cardAction" client/src/hooks/useChatApi.ts
    grep "AdaptiveCardMessage" client/src/components/MessageBubble.tsx
    grep "cardSubmitChip" client/src/components/MessageBubble.tsx
  </verify>
  <done>
    chatApi.ts exports sendCardAction.
    useChatApi.ts exports cardAction function and CARD_ACTION_SUCCESS action is handled.
    TranscriptMessage type has optional subKind field.
    MessageBubble renders AdaptiveCardMessage for adaptiveCard kind.
    MessageBubble renders .cardSubmitChip chip for text messages with subKind='cardSubmit'.
    ChatShell passes cardAction through to TranscriptView and then to MessageBubble.
    TypeScript compiles clean. All tests pass.
  </done>
</task>

</tasks>

<verification>
- npm list adaptivecards --workspace=client shows installed version
- cd client && npx tsc --noEmit exits 0
- npm test exits 0
- grep "AdaptiveCardMessage" client/src/components/MessageBubble.tsx finds a match
- grep "cardSubmitChip" client/src/components/MessageBubble.tsx finds a match
- grep "sendCardAction" client/src/api/chatApi.ts finds a match
- grep "cardAction" client/src/hooks/useChatApi.ts finds matches
</verification>

<success_criteria>
- UI-06: AdaptiveCardMessage uses useRef/useEffect wrapper around adaptivecards SDK (no adaptivecards-react)
- UI-07: onExecuteAction extracts submitData, calls cardAction() → POST /api/chat/card-action
- UI-08: Card is disabled (pointer-events: none, opacity: 0.6) and shows "Submitting…" overlay after first submit; submittedRef prevents double-fire
- UI-10: Card submission adds a distinct .cardSubmitChip transcript entry (subKind: 'cardSubmit')
</success_criteria>

<output>
After completion, create `.planning/phases/03-adaptive-cards-accessibility-theming/03-04-SUMMARY.md`
</output>
