---
phase: 02-text-chat-end-to-end
plan: "04"
type: execute
wave: 4
depends_on:
  - "02-03"
files_modified:
  - client/src/App.tsx
  - client/src/components/ChatShell.tsx
  - client/src/components/TranscriptView.tsx
  - client/src/components/MessageBubble.tsx
  - client/src/components/SkeletonBubble.tsx
  - client/src/components/ChatInput.tsx
  - client/src/components/chat.css
autonomous: false
requirements:
  - UI-02
  - UI-03
  - UI-04
  - UI-05

must_haves:
  truths:
    - "Typing a message and pressing Enter or clicking Send shows the user's bubble instantly (before server responds)"
    - "A skeleton loading row with animated shimmer is visible ~300ms after send while the server is processing"
    - "Bot text response appears in an assistant bubble with distinct visual role styling after the server responds"
    - "When all retries fail, an error message appears inline below the failed user bubble"
    - "The input textarea is disabled while the bot is responding (isLoading === true)"
    - "Both user and bot bubbles show an avatar icon (initials or icon per CONTEXT.md locked decision)"
    - "Input auto-resizes vertically as text wraps, up to a max height, then scrolls within the box"
    - "Enter key sends the message; Shift+Enter inserts a newline"
  artifacts:
    - path: "client/src/components/ChatShell.tsx"
      provides: "Top-level layout wiring useChatApi + TranscriptView + ChatInput"
      exports: ["ChatShell"]
    - path: "client/src/components/TranscriptView.tsx"
      provides: "Scrolling list of MessageBubble and SkeletonBubble components"
      exports: ["TranscriptView"]
    - path: "client/src/components/MessageBubble.tsx"
      provides: "Single message row with avatar + text content + optional inline error"
      exports: ["MessageBubble"]
    - path: "client/src/components/SkeletonBubble.tsx"
      provides: "Animated placeholder row shown during loading"
      exports: ["SkeletonBubble"]
    - path: "client/src/components/ChatInput.tsx"
      provides: "Auto-resize textarea + Send button; disabled during loading"
      exports: ["ChatInput"]
    - path: "client/src/components/chat.css"
      provides: "All chat component styles including skeleton shimmer animation"
    - path: "client/src/App.tsx"
      provides: "Replaced Phase 1 stub; renders ChatShell"
      exports: ["default App"]
  key_links:
    - from: "client/src/App.tsx"
      to: "client/src/components/ChatShell.tsx"
      via: "import and render <ChatShell />"
      pattern: "<ChatShell"
    - from: "client/src/components/ChatShell.tsx"
      to: "client/src/hooks/useChatApi.ts"
      via: "const { messages, isLoading, sendMessage } = useChatApi()"
      pattern: "useChatApi"
    - from: "client/src/components/TranscriptView.tsx"
      to: "client/src/components/MessageBubble.tsx"
      via: "renders MessageBubble for each message"
      pattern: "<MessageBubble"
    - from: "client/src/components/TranscriptView.tsx"
      to: "client/src/components/SkeletonBubble.tsx"
      via: "renders SkeletonBubble when isLoading is true"
      pattern: "<SkeletonBubble"
---

<objective>
Build the React chat UI: ChatShell, TranscriptView, MessageBubble, SkeletonBubble, ChatInput, and update App.tsx to render the chat interface.

Purpose: This is the visible Phase 2 deliverable. All server infrastructure is complete; this plan wires it to a working chat UI that satisfies the success criteria a user can see and interact with.

Output: A working chat UI where a user can type a message, see it appear immediately, watch a loading skeleton while waiting, then see the bot's response appear as a styled bubble — with inline error display and retry on failure.
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/02-text-chat-end-to-end/02-CONTEXT.md
@.planning/phases/02-text-chat-end-to-end/02-RESEARCH.md
@.planning/phases/02-text-chat-end-to-end/02-03-SUMMARY.md
@client/src/hooks/useChatApi.ts
@client/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat components — MessageBubble, SkeletonBubble, TranscriptView, ChatInput, ChatShell, chat.css</name>
  <files>
    client/src/components/MessageBubble.tsx
    client/src/components/SkeletonBubble.tsx
    client/src/components/TranscriptView.tsx
    client/src/components/ChatInput.tsx
    client/src/components/ChatShell.tsx
    client/src/components/chat.css
  </files>
  <action>
    Create all chat components. Use CSS Modules or a single imported `chat.css` file — pick one and be consistent across all components. Use className strings from `chat.css`. No inline styles except for dynamic JS-computed values (e.g., textarea height).

    **chat.css** — must include:
    - `.chatShell` — flex column, full viewport height (`height: 100vh`), background white
    - `.transcriptView` — flex-grow, overflow-y auto, padding 16px, display flex flex-direction column gap 12px
    - `.messageBubble` — display flex, gap 8px, align-items flex-start
    - `.messageBubble.user` — flex-direction row-reverse (user bubbles right-aligned per Claude's discretion: user right, bot left)
    - `.avatar` — 32px × 32px, border-radius 50%, background color, display flex, align-items center, justify-content center, font-size 12px, font-weight 600, flex-shrink 0
    - `.bubbleContent` — max-width 70%, background, border-radius 12px, padding 10px 14px, word-break break-word
    - `.user .bubbleContent` — background #0078d4 (or similar blue), color white
    - `.assistant .bubbleContent` — background #f3f2f1, color #323130
    - `.bubbleContent.sending` — opacity 0.7 (subtle sending indicator per CONTEXT.md)
    - `.inlineError` — font-size 12px, color #a4262c, margin-top 4px, margin-left 40px (indented past avatar)
    - `.skeletonBubble` — display flex, gap 8px
    - `.skeleton` — border-radius 8px, height 44px, background gradient shimmer
    - `@keyframes shimmer` — background-position animation for the skeleton
    - `.chatInputArea` — padding 12px 16px, border-top, background white
    - `.inputRow` — display flex, gap 8px, align-items flex-end
    - `.chatTextarea` — flex-grow, resize none, border, border-radius 8px, padding 10px 12px, font-size 14px, min-height 44px, max-height 160px, overflow-y auto, font-family inherit
    - `.chatTextarea:disabled` — opacity 0.5, cursor not-allowed
    - `.sendButton` — padding 10px 18px, background #0078d4, color white, border none, border-radius 8px, cursor pointer, font-size 14px, height 44px
    - `.sendButton:disabled` — opacity 0.5, cursor not-allowed

    **MessageBubble.tsx**:
    ```tsx
    // Props:
    // message: TranscriptMessage (from useChatApi hook)
    // Component renders:
    // - Avatar: user gets "You" initials, assistant gets "Bot" icon (or similar — Claude's discretion on exact text/icon)
    // - Bubble content: message.text for kind='text'; for kind='adaptiveCard', show a placeholder "[Card — Phase 3]" text (cards are out of scope for Phase 2)
    // - If message.status === 'error': show inline error below bubble with message.errorMessage
    // - Apply 'sending' class to bubbleContent when message.status === 'sending'
    // - Use message.id as React key (parent passes this; component does not need to key itself)
    ```

    **SkeletonBubble.tsx**:
    ```tsx
    // Renders a bot-side skeleton row:
    // - Avatar placeholder (same size as real avatar, grey circle)
    // - Animated shimmer rectangle (className='skeleton')
    // - Add typing dots INSIDE the skeleton using CSS ::after or a nested span with CSS animation
    //   (3 dots fading in sequence; pure CSS — no JS required)
    ```

    **TranscriptView.tsx**:
    ```tsx
    // Props:
    // messages: TranscriptMessage[]
    // isLoading: boolean
    //
    // Renders a scrolling list. For each message: <MessageBubble key={message.id} message={message} />
    // When isLoading === true: append <SkeletonBubble /> at the bottom
    //
    // Auto-scroll: Use useRef on the scroll container. On messages change OR isLoading change,
    // scroll to bottom IF the user is already within 100px of the bottom (smart scroll per Claude's discretion).
    // Use scrollTop + clientHeight >= scrollHeight - 100 to detect "at bottom".
    ```

    **ChatInput.tsx**:
    ```tsx
    // Props:
    // onSend: (text: string) => void
    // disabled: boolean
    //
    // Internal state: text (string), useState
    //
    // Textarea: auto-resize on input using the DOM scrollHeight pattern:
    //   el.style.height = 'auto'; el.style.height = `${Math.min(el.scrollHeight, 160)}px`;
    // Enter key → call onSend(text.trim()) then clear text (unless shift+Enter, which inserts newline)
    // Send button onClick → call onSend(text.trim()) then clear text
    // Both textarea and button must be disabled when props.disabled === true
    // Character limit: 4000 (Claude's discretion). If text.length > 3600, show a counter below the input: "{remaining} characters remaining". Style the counter in red when < 200 chars remain.
    // Do not submit if text.trim() is empty.
    ```

    **ChatShell.tsx**:
    ```tsx
    // Orchestrates the full chat UI.
    // Calls useChatApi() to get { messages, isLoading, sendMessage, error }
    // Renders:
    //   <div className="chatShell">
    //     {error && <div className="globalError">{error}</div>}
    //     <TranscriptView messages={messages} isLoading={isLoading} />
    //     <ChatInput onSend={sendMessage} disabled={isLoading} />
    //   </div>
    // Import useChatApi from '../hooks/useChatApi'
    ```

    Create the `client/src/components/` directory if it does not exist.
    Import `chat.css` in ChatShell.tsx (or each component that uses it — pick one approach and be consistent).
  </action>
  <verify>
    TypeScript compiles clean:
    ```bash
    cd /Users/zycroft/Documents/PA/aaae/client && npx tsc --noEmit
    ```
    All component files exist:
    ```bash
    ls /Users/zycroft/Documents/PA/aaae/client/src/components/
    ```
    No TypeScript errors in any component:
    ```bash
    cd /Users/zycroft/Documents/PA/aaae/client && npx tsc --noEmit 2>&1 | head -30
    ```
  </verify>
  <done>
    All 6 component files exist. TypeScript compiles clean. Components form a coherent hierarchy: ChatShell → (TranscriptView, ChatInput) → (MessageBubble, SkeletonBubble).
  </done>
</task>

<task type="auto">
  <name>Task 2: Update App.tsx to render ChatShell</name>
  <files>client/src/App.tsx</files>
  <action>
    Replace the Phase 1 stub in `client/src/App.tsx` with a real render of `ChatShell`.

    Current content:
    ```tsx
    export default function App() {
      return <div>Copilot Chat — Phase 1 scaffold</div>;
    }
    ```

    Replace with:
    ```tsx
    import { ChatShell } from './components/ChatShell';

    export default function App() {
      return <ChatShell />;
    }
    ```

    Add a minimal global reset to `client/src/main.tsx` if not already present (box-sizing border-box, margin 0, padding 0 on body). Check first — if a `client/src/index.css` or global reset is already imported, don't duplicate.

    Also add basic body styles to `chat.css` or a top-level CSS file:
    ```css
    *, *::before, *::after { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, sans-serif; }
    ```
    (Add only if no existing global styles; avoid duplication.)
  </action>
  <verify>
    TypeScript compiles clean:
    ```bash
    cd /Users/zycroft/Documents/PA/aaae/client && npx tsc --noEmit
    ```
    App.tsx imports ChatShell:
    ```bash
    grep "ChatShell" /Users/zycroft/Documents/PA/aaae/client/src/App.tsx
    ```
  </verify>
  <done>
    `App.tsx` renders `<ChatShell />` instead of the Phase 1 placeholder. TypeScript compiles clean.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Checkpoint: Visual and functional verification of Phase 2 chat UI</name>
  <what-built>
    Full Phase 2 chat UI:
    - server/src/normalizer/activityNormalizer.ts (Activity → NormalizedMessage conversion)
    - server/src/normalizer/activityNormalizer.test.ts (Vitest tests — text, card, hybrid)
    - server/src/routes/chat.ts (POST /api/chat/send added)
    - client/src/api/chatApi.ts (fetch wrappers)
    - client/src/hooks/useChatApi.ts (useReducer state + retry)
    - client/src/components/* (ChatShell, TranscriptView, MessageBubble, SkeletonBubble, ChatInput, chat.css)
    - client/src/App.tsx (renders ChatShell)
  </what-built>
  <how-to-verify>
    **Step 1: Run tests**
    ```bash
    cd /Users/zycroft/Documents/PA/aaae && npm test
    ```
    All tests must pass (including the new normalizer tests).

    **Step 2: Start dev servers**
    ```bash
    cd /Users/zycroft/Documents/PA/aaae && AUTH_REQUIRED=false npm run dev
    ```
    (Set AUTH_REQUIRED=false in server/.env or prefix the command to bypass the auth stub.)

    **Step 3: Open browser**
    Visit http://localhost:5173

    **Verify these behaviors:**
    1. Chat shell renders (transcript area + input area visible, no console errors)
    2. Type a message → user bubble appears IMMEDIATELY before any server response
    3. After ~300ms → skeleton loading row appears below the user bubble
    4. If you have real Copilot credentials: bot response appears as an assistant bubble
    5. If using stub credentials: a 502 error surfaces inline below the user bubble (not a crash)
    6. Input is disabled while the request is in-flight
    7. Both user and bot bubbles show avatar icons
    8. Input auto-resizes as you type long text
    9. Enter sends; Shift+Enter inserts a newline
  </how-to-verify>
  <resume-signal>Type "approved" or describe any visual/functional issues</resume-signal>
  <action>Human verification required — follow the how-to-verify steps above. Start dev servers with AUTH_REQUIRED=false, open http://localhost:5173, and confirm all behaviors listed.</action>
  <verify>User types "approved" after confirming all behaviors in how-to-verify pass.</verify>
  <done>User has confirmed: optimistic bubble, skeleton loading, bot response, inline error on failure, disabled input during load, avatar icons, auto-resize input, Enter-to-send all work correctly.</done>
</task>

</tasks>

<verification>
```bash
cd /Users/zycroft/Documents/PA/aaae && npm test
```
All tests pass (normalizer tests from Plan 02-01 included).

```bash
cd /Users/zycroft/Documents/PA/aaae/client && npx tsc --noEmit
cd /Users/zycroft/Documents/PA/aaae/server && npx tsc --noEmit
```
Both compile clean.
</verification>

<success_criteria>
- [ ] All 6 component files exist in `client/src/components/`
- [ ] `App.tsx` renders `<ChatShell />` (no more Phase 1 placeholder)
- [ ] User bubble appears immediately on send (optimistic, before server responds)
- [ ] Skeleton loading row appears after ~300ms delay
- [ ] Assistant bubble renders bot text with distinct styling from user bubble
- [ ] Both bubbles show avatar icons (user: "You", bot: "Bot" or similar initials)
- [ ] Inline error displayed below user bubble when retries exhausted (not a modal, not a page crash)
- [ ] Input disabled while `isLoading === true`
- [ ] Enter sends; Shift+Enter inserts newline
- [ ] Input auto-resizes up to 160px then scrolls
- [ ] `npm test` passes (all workspaces)
- [ ] Both `client` and `server` TypeScript compile clean
- [ ] User has approved the visual checkpoint
</success_criteria>

<output>
After completion, create `.planning/phases/02-text-chat-end-to-end/02-04-SUMMARY.md`
</output>
