---
phase: 10-orchestrate-endpoint-evaluation
plan: 02
type: execute
wave: 2
depends_on: [10-01]
files_modified:
  - shared/src/schemas/api.ts
  - shared/src/index.ts
  - server/src/routes/orchestrate.ts
  - server/src/app.ts
autonomous: true
requirements: [ORCH-03]

must_haves:
  truths:
    - "POST /api/chat/orchestrate accepts a JSON body with query (required string) and optional workflowContext"
    - "The endpoint starts a Copilot conversation, sends the query with context prefix, normalizes the response, and returns messages + extractedPayload + latencyMs + workflowState"
    - "latencyMs reflects the actual wall-clock time of the Copilot SDK call (not including request parsing)"
    - "Existing /api/chat/start, /api/chat/send, and /api/chat/card-action routes are completely unchanged"
    - "The endpoint uses the same auth middleware, copilotClient singleton, normalizer, and buildContextPrefix as existing routes"
  artifacts:
    - path: "server/src/routes/orchestrate.ts"
      provides: "orchestrateRouter with POST / handler"
      exports: ["orchestrateRouter"]
    - path: "shared/src/schemas/api.ts"
      provides: "OrchestrateRequestSchema and OrchestrateResponseSchema"
      contains: "OrchestrateRequestSchema"
    - path: "server/src/app.ts"
      provides: "orchestrateRouter mounted at /api/chat/orchestrate"
      contains: "orchestrateRouter"
  key_links:
    - from: "server/src/routes/orchestrate.ts"
      to: "server/src/routes/chat.ts"
      via: "imports buildContextPrefix"
      pattern: "buildContextPrefix"
    - from: "server/src/routes/orchestrate.ts"
      to: "server/src/store/index.ts"
      via: "imports workflowStateStore"
      pattern: "workflowStateStore"
    - from: "server/src/app.ts"
      to: "server/src/routes/orchestrate.ts"
      via: "app.use('/api/chat/orchestrate', orchestrateRouter)"
      pattern: "orchestrateRouter"
---

<objective>
Implement the POST /api/chat/orchestrate endpoint that provides a single-call, batteries-included interface for the workflow orchestrator.

Purpose: The orchestrate endpoint consolidates conversation start + message send + normalization + extraction + timing into one request. Future orchestrator code calls this once per turn instead of managing /start and /send separately.

Output: OrchestrateRequest/Response schemas in shared/, orchestrateRouter in server/, mounted in app.ts.
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/10-orchestrate-endpoint-evaluation/10-01-SUMMARY.md
@server/src/routes/chat.ts
@server/src/app.ts
@server/src/store/index.ts
@shared/src/schemas/api.ts
@shared/src/schemas/workflowState.ts
@shared/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Orchestrate request/response schemas in shared/</name>
  <files>shared/src/schemas/api.ts, shared/src/index.ts</files>
  <action>
    Add OrchestrateRequestSchema and OrchestrateResponseSchema to shared/src/schemas/api.ts.

    Import WorkflowContextSchema and WorkflowStateSchema at the top of api.ts:
    ```typescript
    import { WorkflowContextSchema } from './workflowContext.js';
    import { WorkflowStateSchema } from './workflowState.js';
    ```

    Note: WorkflowContextSchema is already imported from Phase 9. Only add the WorkflowStateSchema import.

    OrchestrateRequestSchema:
    ```typescript
    export const OrchestrateRequestSchema = z.object({
      query: z.string().min(1),
      workflowContext: WorkflowContextSchema.optional(),
    });
    export type OrchestrateRequest = z.infer<typeof OrchestrateRequestSchema>;
    ```

    OrchestrateResponseSchema:
    ```typescript
    export const OrchestrateResponseSchema = z.object({
      conversationId: z.string().uuid(),
      messages: z.array(NormalizedMessageSchema),
      extractedPayload: ExtractedPayloadSchema.nullable(),
      latencyMs: z.number().nonneg(),
      workflowState: WorkflowStateSchema,
    });
    export type OrchestrateResponse = z.infer<typeof OrchestrateResponseSchema>;
    ```

    Import ExtractedPayloadSchema at the top of api.ts:
    ```typescript
    import { ExtractedPayloadSchema } from './extractedPayload.js';
    ```

    Add barrel exports to shared/src/index.ts:
    ```typescript
    export {
      OrchestrateRequestSchema,
      type OrchestrateRequest,
      OrchestrateResponseSchema,
      type OrchestrateResponse,
    } from './schemas/api.js';
    ```

    Rebuild shared: `cd shared && npm run build`
  </action>
  <verify>
    `cd /Users/zycroft/Documents/PA/aaae/shared && npm run build` succeeds.
    `npm test` from repo root passes all existing tests.
  </verify>
  <done>
    OrchestrateRequestSchema and OrchestrateResponseSchema are defined in shared/src/schemas/api.ts and exported from shared/src/index.ts. shared/ builds cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement orchestrate route and mount in app.ts</name>
  <files>server/src/routes/orchestrate.ts, server/src/app.ts</files>
  <action>
    Create server/src/routes/orchestrate.ts with a single POST / handler.

    Imports:
    ```typescript
    import { Router } from 'express';
    import { v4 as uuidv4 } from 'uuid';
    import type { Activity } from '@microsoft/agents-activity';
    import { ActivityTypes } from '@microsoft/agents-activity';
    import { OrchestrateRequestSchema, type WorkflowState } from '@copilot-chat/shared';
    import { copilotClient } from '../copilot.js';
    import { conversationStore } from '../store/index.js';
    import { workflowStateStore } from '../store/index.js';
    import { normalizeActivities } from '../normalizer/activityNormalizer.js';
    import { buildContextPrefix } from './chat.js';
    ```

    The handler:
    1. Validate request body with OrchestrateRequestSchema.safeParse
    2. Extract { query, workflowContext }
    3. Start a NEW conversation: copilotClient.startConversationStreaming(true) — consume all activities
    4. Generate conversationId (uuidv4), store in conversationStore
    5. Record start time: `const t0 = performance.now()`
    6. Build outbound text: if workflowContext → buildContextPrefix(workflowContext) + query, else → query
    7. Send via copilotClient.sendActivityStreaming(userActivity), collect activities
    8. Record latencyMs: `Math.round(performance.now() - t0)`
    9. Normalize activities → messages
    10. Extract payload: find first message with extractedPayload, or null
    11. Build workflowState:
        ```typescript
        const existingState = await workflowStateStore.get(conversationId);
        const workflowState: WorkflowState = {
          step: workflowContext?.step ?? 'initial',
          collectedData: workflowContext?.collectedData ?? existingState?.collectedData ?? {},
          lastRecommendation: extractedPayload?.data ? JSON.stringify(extractedPayload.data) : existingState?.lastRecommendation,
          turnCount: (existingState?.turnCount ?? 0) + 1,
        };
        await workflowStateStore.set(conversationId, workflowState);
        ```
    12. Update conversation history in conversationStore
    13. Return: { conversationId, messages, extractedPayload, latencyMs, workflowState }

    Error handling:
    - 400 for invalid request body
    - 502 for Copilot Studio connection failures

    Mount in server/src/app.ts:
    - Import orchestrateRouter from './routes/orchestrate.js'
    - Add `app.use('/api/chat/orchestrate', orchestrateRouter);` AFTER the chatRouter line
    - Do NOT modify existing chatRouter mounting

    CONSTRAINT: Do NOT modify server/src/routes/chat.ts — only import buildContextPrefix from it.
  </action>
  <verify>
    1. `npm run build` from repo root completes without TypeScript errors
    2. `npm test` from repo root passes all existing tests (54+)
    3. Check that /start, /send, /card-action routes are unchanged in chat.ts
  </verify>
  <done>
    POST /api/chat/orchestrate is available. It starts a conversation, sends a message with optional context, normalizes the response, measures latency, and returns the full orchestrator payload. Existing routes are untouched.
  </done>
</task>

</tasks>

<verification>
- `npm run build` passes (TypeScript types from shared rebuild consumed correctly)
- `npm test` passes all suites
- server/src/routes/chat.ts is unchanged from Phase 9 (verify with `git diff HEAD server/src/routes/chat.ts` shows no changes)
- server/src/app.ts has orchestrateRouter mounted
</verification>

<success_criteria>
POST /api/chat/orchestrate accepts a query with optional workflowContext, calls the Copilot SDK, and returns messages + extractedPayload + latencyMs + workflowState in a single response. All existing tests pass and no existing routes are modified.
</success_criteria>

<output>
After completion, create `.planning/phases/10-orchestrate-endpoint-evaluation/10-02-SUMMARY.md`
</output>
