---
phase: 17-route-integration-compatibility
plan: 02
type: execute
wave: 2
depends_on: [17-01]
files_modified:
  - server/src/routes/chat.ts
autonomous: true
requirements: [ROUTE-01, ROUTE-02, ROUTE-03, COMPAT-01, COMPAT-02, COMPAT-03]

must_haves:
  truths:
    - "POST /api/chat/start calls orchestrator.startSession() and returns workflowState in response"
    - "POST /api/chat/send calls orchestrator.processTurn() with userId/tenantId from JWT and returns workflowState"
    - "POST /api/chat/card-action validates allowlist FIRST (403 on violation), THEN calls orchestrator.processCardAction()"
    - "No direct copilotClient.sendActivityStreaming() or copilotClient.startConversationStreaming() calls remain in chat.ts"
    - "A plain text Copilot response (passthrough mode) returns identical messages content to v1.4 with added optional workflowState field"
    - "Allowlist violations on /api/chat/card-action still return 403 before reaching the orchestrator"
    - "isRedisError() error handling is preserved: Redis failures return 503, other failures return 502"
    - "req.user?.oid and req.user?.tid are extracted from JWT claims and passed to orchestrator (fallback: 'anonymous', 'dev')"
  artifacts:
    - path: "server/src/routes/chat.ts"
      provides: "Orchestrator-delegating chat routes"
      contains: "orchestrator.startSession"
  key_links:
    - from: "server/src/routes/chat.ts"
      to: "server/src/orchestrator/index.ts"
      via: "import { orchestrator } from '../orchestrator/index.js'"
      pattern: "orchestrator\\.(startSession|processTurn|processCardAction)"
    - from: "server/src/routes/chat.ts"
      to: "server/src/allowlist/cardActionAllowlist.ts"
      via: "validateCardAction before orchestrator.processCardAction"
      pattern: "validateCardAction.*allowlistResult.*orchestrator"
---

<objective>
Replace direct Copilot Studio calls in server/src/routes/chat.ts with orchestrator delegation. All three routes (/start, /send, /card-action) become thin adapters: validate request, extract JWT claims, delegate to orchestrator, return extended response with optional workflowState.

Purpose: This is the core integration that makes the WorkflowOrchestrator (built in Phase 16) actually handle production traffic. The buildContextPrefix function and manual Copilot call loops are removed; the orchestrator handles state, locking, context enrichment, parsing, and data accumulation.

Output: Updated chat.ts with three orchestrator-delegating routes. No direct copilotClient calls remain in this file. Backward compatibility preserved via optional workflowState field in responses.
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-route-integration-compatibility/17-01-SUMMARY.md
@server/src/routes/chat.ts
@server/src/orchestrator/index.ts
@server/src/orchestrator/WorkflowOrchestrator.ts
@server/src/allowlist/cardActionAllowlist.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite chat.ts routes to delegate to orchestrator singleton</name>
  <files>server/src/routes/chat.ts</files>
  <action>
    Rewrite server/src/routes/chat.ts to delegate all three routes to the orchestrator singleton.
    The orchestrator singleton is exported from '../orchestrator/index.js' as `orchestrator`.

    **REMOVE from the file:**
    - buildContextPrefix function (no longer needed — orchestrator.buildContextualQuery handles this)
    - All direct copilotClient.sendActivityStreaming() and copilotClient.startConversationStreaming() call loops
    - Manual normalizeActivities() calls in routes (orchestrator handles normalization)
    - Manual conversationStore.set() calls in routes (orchestrator handles store updates)
    - Unused imports after refactor: copilotClient, conversationStore, normalizeActivities, Activity, ActivityTypes, WorkflowContext

    **REPLACE each route:**

    POST /start:
    ```typescript
    chatRouter.post('/start', async (req, res) => {
      try {
        const conversationId = uuidv4();
        const workflowState = await orchestrator.startSession({
          conversationId,
          userId: req.user?.oid ?? 'anonymous',
          tenantId: req.user?.tid ?? 'dev',
        });
        res.status(200).json({ conversationId, workflowState });
      } catch (err) {
        console.error('[chat/start] Error starting conversation:', err);
        if (isRedisError(err)) {
          res.status(503).json({ error: 'Service Unavailable: Redis backend offline' });
        } else {
          res.status(502).json({ error: 'Failed to start conversation with Copilot Studio' });
        }
      }
    });
    ```

    POST /send:
    ```typescript
    chatRouter.post('/send', async (req, res) => {
      const parsed = SendMessageRequestSchema.safeParse(req.body);
      if (!parsed.success) {
        res.status(400).json({ error: 'Invalid request', details: parsed.error.format() });
        return;
      }
      const { conversationId, text } = parsed.data;

      try {
        const workflowResponse = await orchestrator.processTurn({
          conversationId,
          text,
          userId: req.user?.oid ?? 'anonymous',
          tenantId: req.user?.tid ?? 'dev',
        });
        res.status(200).json({
          conversationId: workflowResponse.conversationId,
          messages: workflowResponse.messages,
          workflowState: workflowResponse.workflowState,
        });
      } catch (err) {
        console.error('[chat/send] Error sending message:', err);
        if (isRedisError(err)) {
          res.status(503).json({ error: 'Service Unavailable: Redis backend offline' });
        } else {
          res.status(502).json({ error: 'Failed to send message to Copilot Studio' });
        }
      }
    });
    ```

    POST /card-action:
    ```typescript
    chatRouter.post('/card-action', async (req, res) => {
      const parsed = CardActionRequestSchema.safeParse(req.body);
      if (!parsed.success) {
        res.status(400).json({ error: 'Invalid request', details: parsed.error.format() });
        return;
      }
      const { conversationId, cardId, userSummary, submitData } = parsed.data;

      // COMPAT-02: Allowlist validation BEFORE orchestrator — preserve 403 contract
      const allowlistResult = validateCardAction(submitData);
      if (!allowlistResult.ok) {
        console.warn(`[chat/card-action] Rejected: ${allowlistResult.reason}`);
        res.status(403).json({ error: allowlistResult.reason });
        return;
      }

      try {
        const workflowResponse = await orchestrator.processCardAction({
          conversationId,
          cardId,
          userSummary,
          submitData,
          userId: req.user?.oid ?? 'anonymous',
          tenantId: req.user?.tid ?? 'dev',
        });
        res.status(200).json({
          conversationId: workflowResponse.conversationId,
          messages: workflowResponse.messages,
          workflowState: workflowResponse.workflowState,
        });
      } catch (err) {
        console.error('[chat/card-action] Error forwarding card action:', err);
        if (isRedisError(err)) {
          res.status(503).json({ error: 'Service Unavailable: Redis backend offline' });
        } else {
          res.status(502).json({ error: 'Failed to forward card action to Copilot Studio' });
        }
      }
    });
    ```

    **Note on /send backward compatibility:** The old /send route had a conversationStore.get() check that returned 404 if the conversation wasn't found. The orchestrator.processTurn() internally loads state from workflowStore and falls back to creating a new state if none exists. The 404 check is dropped — the orchestrator handles missing state gracefully. This is acceptable because the orchestrator is now the source of truth for conversation lifecycle.

    **Note on workflowContext in /send request schema:** The SendMessageRequestSchema still has workflowContext as an optional field for backward compatibility. The route no longer uses it directly — the orchestrator enriches queries from its own stored WorkflowState. The field is accepted but ignored in the route (no breaking change for clients that send it).

    After editing chat.ts, verify TypeScript compilation:
    ```
    cd server && npx tsc --noEmit
    ```
    Fix any type errors before proceeding.

    Also note: the orchestrate.ts route imports buildContextPrefix from chat.ts. Since buildContextPrefix is being removed from chat.ts, update orchestrate.ts to inline its own context prefix logic or remove the dependency. Check: grep -n "buildContextPrefix" server/src/routes/orchestrate.ts. If it imports buildContextPrefix, either inline the function in orchestrate.ts or keep a copy there.
  </action>
  <verify>
    1. Run: cd /Users/zycroft/Documents/PA/aaae && npx tsc -p server/tsconfig.json --noEmit
       Expected: 0 errors

    2. Run: cd /Users/zycroft/Documents/PA/aaae && npm test
       Expected: All 142+ tests pass (no regressions)

    3. Verify no direct copilotClient calls remain in chat.ts:
       grep -n "sendActivityStreaming\|startConversationStreaming" server/src/routes/chat.ts
       Expected: No matches (empty output)

    4. Verify orchestrator import is present:
       grep -n "orchestrator" server/src/routes/chat.ts
       Expected: import line + usage in all three routes
  </verify>
  <done>
    chat.ts delegates all three routes to orchestrator singleton.
    buildContextPrefix is removed from chat.ts.
    No direct copilotClient streaming calls remain in chat.ts.
    All tests pass (142+ green).
    TypeScript compiles with 0 errors.
    /start returns { conversationId, workflowState }.
    /send returns { conversationId, messages, workflowState }.
    /card-action validates allowlist first (403 preserved), then returns { conversationId, messages, workflowState }.
  </done>
</task>

</tasks>

<verification>
- grep "sendActivityStreaming\|startConversationStreaming" server/src/routes/chat.ts → empty (no direct Copilot calls)
- grep "orchestrator\." server/src/routes/chat.ts → startSession, processTurn, processCardAction all present
- npm test passes (all 142+ tests green)
- TypeScript: npx tsc -p server/tsconfig.json --noEmit → 0 errors
</verification>

<success_criteria>
All three chat routes delegate to the WorkflowOrchestrator singleton. Responses include optional workflowState. Allowlist validation order preserved on /card-action. All existing tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/17-route-integration-compatibility/17-02-SUMMARY.md`
</output>
