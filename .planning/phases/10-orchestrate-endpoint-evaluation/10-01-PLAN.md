---
phase: 10-orchestrate-endpoint-evaluation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - shared/src/schemas/workflowState.ts
  - shared/src/index.ts
  - server/src/store/WorkflowStateStore.ts
  - server/src/store/InMemoryWorkflowStateStore.ts
  - server/src/store/index.ts
autonomous: true
requirements: [ORCH-01, ORCH-02]

must_haves:
  truths:
    - "WorkflowStateSchema validates step (required string), collectedData (optional record), lastRecommendation (optional string), turnCount (non-negative integer)"
    - "WorkflowStateSchema rejects objects missing required step field"
    - "WorkflowStateStore interface defines get, set, delete methods with WorkflowState values"
    - "InMemoryWorkflowStateStore implements WorkflowStateStore with in-memory Map"
    - "WorkflowState type is exported from @copilot-chat/shared for server consumption"
  artifacts:
    - path: "shared/src/schemas/workflowState.ts"
      provides: "WorkflowStateSchema and WorkflowState type"
      exports: ["WorkflowStateSchema", "WorkflowState"]
    - path: "server/src/store/WorkflowStateStore.ts"
      provides: "WorkflowStateStore interface"
      exports: ["WorkflowStateStore"]
    - path: "server/src/store/InMemoryWorkflowStateStore.ts"
      provides: "InMemoryWorkflowStateStore implementation"
      exports: ["InMemoryWorkflowStateStore"]
    - path: "shared/src/index.ts"
      provides: "Barrel export of WorkflowState types"
      contains: "WorkflowStateSchema"
  key_links:
    - from: "server/src/store/InMemoryWorkflowStateStore.ts"
      to: "server/src/store/WorkflowStateStore.ts"
      via: "implements WorkflowStateStore"
      pattern: "implements WorkflowStateStore"
    - from: "shared/src/index.ts"
      to: "shared/src/schemas/workflowState.ts"
      via: "re-export"
      pattern: "WorkflowStateSchema"
---

<objective>
Define the WorkflowState Zod schema in shared/ and create the WorkflowStateStore interface with an in-memory implementation in server/.

Purpose: The orchestrate endpoint needs a typed state container to track multi-turn workflow progress. WorkflowState holds the current step, accumulated data, the last agent recommendation, and turn count. The store interface follows the existing ConversationStore pattern for consistency.

Output: WorkflowStateSchema in shared/, WorkflowStateStore interface + InMemoryWorkflowStateStore in server/, types barrel-exported.
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@shared/src/schemas/workflowContext.ts
@shared/src/index.ts
@server/src/store/ConversationStore.ts
@server/src/store/InMemoryStore.ts
@server/src/store/index.ts
</context>

<feature>
  <name>WorkflowState schema + WorkflowStateStore</name>
  <files>shared/src/schemas/workflowState.ts, shared/src/schemas/workflowState.test.ts, server/src/store/WorkflowStateStore.ts, server/src/store/InMemoryWorkflowStateStore.ts</files>
  <behavior>
    WorkflowStateSchema shape:
      - step: z.string().min(1)                                    — required, current workflow step
      - collectedData: z.record(z.string(), z.unknown()).optional() — accumulated KV bag
      - lastRecommendation: z.string().optional()                  — extracted from last agent response
      - turnCount: z.number().int().nonneg()                       — incremented per orchestrate call

    Cases:
      { step: "gather-name", turnCount: 0 }
        → valid (minimal)

      { step: "confirm", collectedData: { name: "Alice" }, lastRecommendation: "ask for budget", turnCount: 3 }
        → valid (full)

      {}
        → INVALID (step required)

      { step: "", turnCount: 0 }
        → INVALID (step min(1))

      { step: "s", turnCount: -1 }
        → INVALID (turnCount must be non-negative)

    WorkflowStateStore interface:
      get(conversationId: string): Promise&lt;WorkflowState | undefined&gt;
      set(conversationId: string, state: WorkflowState): Promise&lt;void&gt;
      delete(conversationId: string): Promise&lt;void&gt;

    InMemoryWorkflowStateStore:
      - Uses Map&lt;string, WorkflowState&gt;
      - Same pattern as InMemoryConversationStore
  </behavior>
  <implementation>
    1. Create shared/src/schemas/workflowState.ts with WorkflowStateSchema
    2. Re-export WorkflowStateSchema and WorkflowState type from shared/src/index.ts
    3. Create server/src/store/WorkflowStateStore.ts with interface definition
    4. Create server/src/store/InMemoryWorkflowStateStore.ts implementing the interface
    5. Export workflowStateStore singleton from server/src/store/index.ts
    6. Rebuild shared: cd shared && npm run build
    7. Run npm test from repo root to confirm all existing tests pass
  </implementation>
</feature>

<verification>
- `cd /Users/zycroft/Documents/PA/aaae/shared && npm run build` completes without errors
- `npm test` from repo root passes all existing tests + new schema tests
- WorkflowStateSchema validates correctly (valid inputs parse, invalid inputs throw)
</verification>

<success_criteria>
WorkflowStateSchema is the source of truth in shared/. WorkflowStateStore interface mirrors ConversationStore pattern. InMemoryWorkflowStateStore provides the in-memory implementation. All pre-existing tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/10-orchestrate-endpoint-evaluation/10-01-SUMMARY.md`
</output>
