---
phase: 07-client-msal-authentication
plan: "03"
type: execute
wave: 3
depends_on:
  - "07-02"
files_modified:
  - client/src/api/chatApi.ts
  - client/src/components/ChatShell.tsx
  - client/src/components/chat.css
autonomous: true
requirements:
  - CAUTH-04
  - CAUTH-05
  - CAUTH-06
  - CAUTH-07
  - TEST-03

must_haves:
  truths:
    - "Every API call (start, send, card-action) includes Authorization: Bearer {token} automatically"
    - "Token is acquired silently before each request; redirect fallback fires if silent fails"
    - "User can sign out from the chat UI — MSAL cache cleared, browser returns to sign-in page"
    - "Token refresh is silent and does not interrupt the chat session (no visible UI change)"
    - "npm test and npm run build pass with no new failures"
  artifacts:
    - path: "client/src/api/chatApi.ts"
      provides: "All fetch wrappers now accept and send Authorization header"
      exports: ["startConversation", "sendMessage", "sendCardAction"]
    - path: "client/src/components/ChatShell.tsx"
      provides: "Sign-out button in header area; acquireToken logic via hook"
      contains: "signOut"
  key_links:
    - from: "client/src/components/ChatShell.tsx"
      to: "client/src/api/chatApi.ts"
      via: "passes Bearer token to every API call"
      pattern: "Bearer.*token|getToken"
    - from: "client/src/components/ChatShell.tsx"
      to: "useMsal"
      via: "acquireTokenSilent + loginRedirect fallback"
      pattern: "acquireTokenSilent|loginRedirect"
    - from: "client/src/components/ChatShell.tsx"
      to: "msalInstance.logoutRedirect"
      via: "sign-out button onClick"
      pattern: "logoutRedirect|logout"

user_setup:
  - service: azure-ad
    why: "MSAL requires an actual Azure App Registration to redirect to Entra External ID. Without real VITE_AZURE_CLIENT_ID and VITE_AZURE_TENANT_NAME values, sign-in will fail at the Entra redirect."
    env_vars:
      - name: VITE_AZURE_CLIENT_ID
        source: "Azure Portal > App Registrations > your client SPA app > Overview > Application (client) ID"
      - name: VITE_AZURE_TENANT_NAME
        source: "Azure Portal > your Entra External ID tenant > Overview > Tenant name (e.g. 'contoso' from contoso.ciamlogin.com)"
      - name: VITE_AZURE_REDIRECT_URI
        source: "http://localhost:5173 for dev (must be registered in Azure Portal > App Registration > Authentication > Single-page application redirect URIs)"
    dashboard_config:
      - task: "Register a Single Page Application"
        location: "Azure Portal > App Registrations > New registration > Platform: Single-page application > Redirect URI: http://localhost:5173"
      - task: "Expose API scope on server app registration"
        location: "Azure Portal > App Registrations > server app > Expose an API > Add scope: 'access_as_user'"
      - task: "Grant client app permission to server API"
        location: "Azure Portal > App Registrations > client SPA app > API permissions > Add permission > My APIs > select server app > access_as_user"
---

<objective>
Add Bearer token injection to all API calls, add sign-out capability to ChatShell, and verify CI passes.

Purpose: Completes the authentication loop — authenticated users have tokens automatically attached to every API request (CAUTH-05), tokens refresh silently without breaking the conversation (CAUTH-07), and users can sign out (CAUTH-06). This plan makes the full auth feature operational end-to-end.

Output: Updated `chatApi.ts` accepting Bearer tokens, updated `ChatShell.tsx` with token acquisition and sign-out, CI green.
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-client-msal-authentication/07-CONTEXT.md
@.planning/phases/07-client-msal-authentication/07-02-SUMMARY.md
@client/src/api/chatApi.ts
@client/src/components/ChatShell.tsx
@client/src/components/chat.css
@client/src/auth/msalConfig.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Bearer token parameter to all chatApi.ts fetch wrappers</name>
  <files>client/src/api/chatApi.ts</files>
  <action>
    Update `client/src/api/chatApi.ts` to accept a `token` parameter in each function and inject it as the `Authorization: Bearer` header.

    **Pattern:** Add `token: string` as the first parameter (before `signal?: AbortSignal`) to each exported function. Inject it into the `headers` object. Do NOT acquire the token inside chatApi.ts — token acquisition is a concern of the caller (ChatShell via useMsal).

    Updated function signatures:

    ```typescript
    export async function startConversation(
      token: string,
      signal?: AbortSignal,
    ): Promise<{ conversationId: string }>

    export async function sendMessage(
      conversationId: string,
      text: string,
      token: string,
      signal?: AbortSignal,
    ): Promise<{ conversationId: string; messages: NormalizedMessage[] }>

    export async function sendCardAction(
      conversationId: string,
      cardId: string,
      userSummary: string,
      submitData: Record<string, unknown>,
      token: string,
      signal?: AbortSignal,
    ): Promise<{ conversationId: string; messages: NormalizedMessage[] }>
    ```

    For each function, update the `headers` object:
    ```typescript
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`,
    },
    ```

    Full replacement of `chatApi.ts` with updated signatures — keep all existing error handling, JSON parsing, and AbortSignal logic unchanged. Only add the `token` parameter and header injection.

    Note: `startConversation` uses POST with no body currently — add `Content-Type` and `Authorization` headers. The server's auth middleware reads the Authorization header on all `/api/*` routes, so the header is required even for the start endpoint.
  </action>
  <verify>
    1. Run `cd client && npx tsc --noEmit` — must compile clean (TypeScript will flag if callers in useChatApi.ts don't pass the token arg, fixing those is part of Task 2).
    2. Grep `client/src/api/chatApi.ts` for `Authorization` — must appear 3 times (once per function).
  </verify>
  <done>All three functions in `chatApi.ts` accept `token: string` and inject `Authorization: Bearer ${token}` into request headers.</done>
</task>

<task type="auto">
  <name>Task 2: Add token acquisition, token forwarding, and sign-out to ChatShell</name>
  <files>client/src/components/ChatShell.tsx, client/src/components/chat.css</files>
  <action>
    Update `client/src/components/ChatShell.tsx` to:
    1. Acquire tokens silently before API calls, with redirect fallback
    2. Pass tokens to all chatApi calls (via useChatApi or directly)
    3. Add a sign-out button in the header area

    **Approach:** Create a `useToken` helper inline or as a small hook that wraps `acquireTokenSilent`. Because `useChatApi` is the call site for chatApi functions, the cleanest approach is to inject a `getToken` async function into `useChatApi` — but that would require modifying the hook signature. Instead, acquire the token in `ChatShell` and pass it down to `useChatApi` as a prop/dependency.

    **Simpler approach (preferred):** Modify `useChatApi.ts` to accept a `getToken: () => Promise<string>` parameter, and call it before each API call. ChatShell creates this function using `useMsal` and passes it to the hook.

    **Updated `client/src/hooks/useChatApi.ts` signature change:**
    Add `getToken: () => Promise<string>` as a parameter to the `useChatApi` hook (destructured from a config object to avoid positional arg brittleness):
    ```typescript
    export function useChatApi({ getToken }: { getToken: () => Promise<string> }) { ... }
    ```
    Inside `useChatApi`, before each `chatApi.*` call, await `getToken()` and pass the result as the `token` argument.

    **Updated `client/src/components/ChatShell.tsx`:**

    ```typescript
    import './chat.css';
    import { useMsal } from '@azure/msal-react';
    import { useCallback } from 'react';
    import { useChatApi } from '../hooks/useChatApi.js';
    import { useTheme } from '../hooks/useTheme.js';
    import { TranscriptView } from './TranscriptView.js';
    import { ChatInput } from './ChatInput.js';
    import { ThemeToggle } from './ThemeToggle.js';
    import { MetadataPane } from './MetadataPane.js';
    import { loginRequest, msalInstance } from '../auth/msalConfig.js';

    export function ChatShell() {
      const { instance, accounts } = useMsal();
      const { theme, toggle } = useTheme();

      /**
       * Acquires a valid access token for the server API.
       * 1. Try silent acquisition (uses cached token if valid, refreshes if near-expiry)
       * 2. If silent fails (interaction_required or network error): fall back to loginRedirect
       *
       * CAUTH-04, CAUTH-07: Silent refresh keeps session alive without UI disruption.
       */
      const getToken = useCallback(async (): Promise<string> => {
        const account = accounts[0];
        try {
          const result = await instance.acquireTokenSilent({
            ...loginRequest,
            account,
          });
          return result.accessToken;
        } catch {
          // Silent failed — redirect to Entra for re-authentication
          // This handles: token expired beyond refresh window, interaction_required, network errors
          await instance.loginRedirect(loginRequest);
          // loginRedirect navigates away; this line never executes
          throw new Error('Redirecting to sign-in');
        }
      }, [instance, accounts]);

      /**
       * Signs the user out: clears MSAL token cache, redirects browser to sign-in page.
       * No confirmation dialog per CONTEXT.md decision.
       * CAUTH-06
       */
      function handleSignOut() {
        void msalInstance.logoutRedirect({
          account: accounts[0],
          postLogoutRedirectUri: window.location.origin,
        });
      }

      const { messages, isLoading, error, sendMessage, cardAction } = useChatApi({ getToken });

      return (
        <div className="appLayout">
          <div className="chatPane">
            <div className="chatShell">
              {error && <div className="globalError">{error}</div>}
              <div className="chatHeader">
                <ThemeToggle theme={theme} onToggle={toggle} />
                <button
                  type="button"
                  className="signOutButton"
                  onClick={handleSignOut}
                  aria-label="Sign out"
                >
                  Sign out
                </button>
              </div>
              <TranscriptView messages={messages} isLoading={isLoading} onCardAction={cardAction} />
              <ChatInput onSend={sendMessage} disabled={isLoading} />
            </div>
          </div>
          <MetadataPane messages={messages} />
        </div>
      );
    }
    ```

    **Also update `client/src/hooks/useChatApi.ts`:**
    - Change signature from `export function useChatApi()` to `export function useChatApi({ getToken }: { getToken: () => Promise<string> })`
    - Before each `startConversation()` call: `const token = await getToken(); await startConversation(token, signal);`
    - Before each `sendMessage()` call: `const token = await getToken(); await sendMessage(conversationId, text, token, signal);`
    - Before each `sendCardAction()` call: `const token = await getToken(); await sendCardAction(..., token, signal);`
    - Token acquisition failure (getToken throws) should be treated like a network error — caught by existing try/catch and shown as an error state.

    **Add to `client/src/components/chat.css`** (append after auth UI section added in Plan 02):

    ```css
    /* ── Chat header — contains ThemeToggle and Sign-out button ─────────────── */
    .chatHeader {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: var(--space-2);
      position: relative;
    }

    /* Sign-out button in chat header */
    .signOutButton {
      background: none;
      border: 1px solid var(--color-border);
      border-radius: 4px;
      color: var(--color-text-muted);
      cursor: pointer;
      font-size: var(--font-size-sm);
      padding: var(--space-1) var(--space-3);
      transition: color var(--transition-base), border-color var(--transition-base);
    }

    .signOutButton:hover {
      color: var(--color-text);
      border-color: var(--color-text-muted);
    }

    .signOutButton:focus-visible {
      outline: 2px solid var(--color-focus-ring);
      outline-offset: 2px;
    }
    ```

    Also update `ChatShell.tsx`: remove the previous `position: relative` ThemeToggle assumption — `ThemeToggle` was previously absolutely positioned. With the new `.chatHeader` flex container, `ThemeToggle`'s CSS class `.themeToggle` may need `position: static` instead of `position: absolute`. Check the existing `.themeToggle` CSS rule and update if it uses `position: absolute` (change to `position: static` or remove the absolute positioning so it flows naturally in the flex container).
  </action>
  <verify>
    1. Run `cd client && npx tsc --noEmit` — must compile without errors. TypeScript will catch any missing token arguments to chatApi functions.
    2. Grep `client/src/hooks/useChatApi.ts` for `getToken` — must appear (token acquisition before each API call).
    3. Grep `client/src/components/ChatShell.tsx` for `signOutButton` — must appear (sign-out button in JSX).
    4. Grep `client/src/components/ChatShell.tsx` for `acquireTokenSilent` — must appear.
    5. Grep `client/src/components/chat.css` for `.signOutButton` — must exist.
  </verify>
  <done>
    - `useChatApi` accepts `getToken` param and calls it before each API request
    - `ChatShell` creates `getToken` via `acquireTokenSilent` with `loginRedirect` fallback
    - Sign-out button visible in chat header; clicking calls `logoutRedirect`
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify CI passes (build + tests)</name>
  <files></files>
  <action>
    Run the full test and build suite to confirm TEST-03: CI continues to pass with the new auth code.

    Run in order from the repo root:
    ```bash
    npm run build
    npm test
    npm run lint
    ```

    Expected outcomes:
    - `npm run build`: shared → client → server all compile without errors. MSAL packages are tree-shaken properly by Vite.
    - `npm test`: All existing tests pass. No new test files were added in Phase 7 (MSAL React flow is UI/integration tested, not unit tested at this layer — the hooks rely on MSAL internals that would require complex mocking). Jest for client passes with `--passWithNoTests` if no client tests exist for auth.
    - `npm run lint`: ESLint passes. Note: there are 3 pre-existing lint errors in AdaptiveCardMessage.tsx and ChatInput.tsx (documented in STATE.md as known debt). These are pre-existing and non-blocking.

    If `npm run lint` fails due to new lint errors in auth files:
    - Fix any `@typescript-eslint` violations (unused vars, explicit any, etc.)
    - Do NOT suppress errors with eslint-disable comments unless there is a genuine false positive
    - Common MSAL pattern: `void` operator for floating promises in event handlers is the correct pattern (already used in SignInPage and ChatShell)

    If `npm run build` fails:
    - Check that `client/src/auth/` `.js` extensions are used in all import paths (NodeNext module resolution requires explicit extensions)
    - Verify `@azure/msal-browser` and `@azure/msal-react` are installed (from Plan 01)
    - Check that `msalConfig.ts` uses `import.meta.env` (not `process.env`) — Vite replaces these at build time

    If tests fail:
    - Identify which test file and what error
    - If it's a pre-existing failure (documented in STATE.md), note it
    - If it's a new failure introduced by Phase 7, fix it before completing this task
  </action>
  <verify>
    All three commands complete without new errors:
    - `npm run build` exit code 0
    - `npm test` exit code 0 (pre-existing lint errors in AdaptiveCardMessage.tsx/ChatInput.tsx are not failures)
    - `npm run lint` exit code 0 (or only pre-existing errors)
  </verify>
  <done>
    - `npm run build` succeeds — all three workspaces compile
    - `npm test` succeeds — all tests pass
    - `npm run lint` produces only pre-existing errors (3 known, non-blocking)
    - TEST-03 satisfied: CI continues to pass with new auth code
  </done>
</task>

</tasks>

<verification>
Phase 7 complete when all of the following are true:
1. `npm run build` succeeds across all workspaces
2. `npm test` passes (all tests green)
3. `client/src/auth/` contains: `msalConfig.ts`, `AuthProvider.tsx`, `AuthGuard.tsx`, `SignInPage.tsx`
4. `client/src/api/chatApi.ts` — all three functions include `Authorization: Bearer` header
5. `client/src/hooks/useChatApi.ts` — accepts `getToken` and calls it before each API request
6. `client/src/components/ChatShell.tsx` — contains `acquireTokenSilent` and `logoutRedirect` calls
7. Sign-out button rendered in chat header area
8. `chat.css` contains `.signInLayout`, `.signInCard`, `.signInButton`, `.welcomeToast`, `.signOutButton`, `.chatHeader`
9. `main.tsx` wraps App in `AuthProvider`; `App.tsx` wraps ChatShell in `AuthGuard`
</verification>

<success_criteria>
- CAUTH-01: Unauthenticated → SignInPage shown, chat UI inaccessible
- CAUTH-02: Sign-in button → loginRedirect → Entra External ID login
- CAUTH-03: Post-auth chat is functionally identical to v1.1 (text, cards, metadata, theme all work)
- CAUTH-04: Token acquired silently on each request; redirect fallback on silent failure
- CAUTH-05: Authorization: Bearer header present on start, send, and card-action requests
- CAUTH-06: Sign-out button visible; clicking clears MSAL cache and returns to sign-in page
- CAUTH-07: Silent token refresh (acquireTokenSilent) runs without UI disruption mid-conversation
- TEST-03: `npm run build` and `npm test` pass with no new failures
</success_criteria>

<output>
After completion, create `.planning/phases/07-client-msal-authentication/07-03-SUMMARY.md`
</output>
