---
phase: 01-scaffold-schema-server-foundation
plan: 03
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - server/src/config.ts
  - server/src/middleware/auth.ts
  - server/src/store/ConversationStore.ts
  - server/src/store/InMemoryStore.ts
  - server/src/store/index.ts
  - server/src/app.ts
  - server/src/index.ts
autonomous: true
requirements:
  - SERV-01
  - SERV-05
  - SERV-09
  - SERV-10

must_haves:
  truths:
    - "Express server starts on PORT from env (default 3001) without errors"
    - "Request without Authorization header when AUTH_REQUIRED=true returns 401 JSON response"
    - "Request without Authorization header when AUTH_REQUIRED=false proceeds to next middleware (not 401)"
    - "AUTH_REQUIRED defaults to true when env var is absent (fail-closed)"
    - "CORS allows requests from CORS_ORIGIN env var only (not wildcard)"
    - "ConversationStore interface is implemented by InMemoryConversationStore with LRU eviction"
    - "config.ts validates required env vars and calls process.exit(1) on missing COPILOT_ENVIRONMENT_ID or COPILOT_AGENT_SCHEMA_NAME"
  artifacts:
    - path: "server/src/config.ts"
      provides: "Validated env var config object; calls process.exit(1) on missing required vars"
      exports: ["config"]
    - path: "server/src/middleware/auth.ts"
      provides: "Fail-closed auth middleware with TODO for MSAL OBO"
      exports: ["authMiddleware"]
    - path: "server/src/store/ConversationStore.ts"
      provides: "ConversationStore interface and StoredConversation type"
      exports: ["ConversationStore", "StoredConversation"]
    - path: "server/src/store/InMemoryStore.ts"
      provides: "LRU-backed ConversationStore implementation (max 100 conversations)"
      exports: ["InMemoryConversationStore"]
    - path: "server/src/app.ts"
      provides: "Express app factory with CORS, JSON middleware, and auth middleware wired"
      exports: ["createApp"]
    - path: "server/src/index.ts"
      provides: "Entry point that loads config, creates app, and starts listening"
  key_links:
    - from: "server/src/index.ts"
      to: "server/src/config.ts"
      via: "import at top — MUST be first import so validation runs before anything else"
      pattern: "import.*config.*from.*config"
    - from: "server/src/app.ts"
      to: "server/src/middleware/auth.ts"
      via: "app.use(authMiddleware)"
      pattern: "authMiddleware"
    - from: "server/src/app.ts"
      to: "cors"
      via: "app.use(cors({ origin: config.CORS_ORIGIN }))"
      pattern: "cors.*CORS_ORIGIN"
    - from: "server/src/store/InMemoryStore.ts"
      to: "lru-cache"
      via: "LRUCache import"
      pattern: "LRUCache"
---

<objective>
Implement the Express server foundation: env var config validation, fail-closed auth middleware, CORS setup, ConversationStore interface with LRU-backed implementation, and the Express app factory.

Purpose: This is the server skeleton that Plan 04 (POST /api/chat/start) builds on. The auth middleware, CORS, and store are shared across all routes.
Output: A running Express server with fail-closed auth, specific-origin CORS, and a working ConversationStore.
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01-scaffold-schema-server-foundation/01-RESEARCH.md
@.planning/phases/01-scaffold-schema-server-foundation/01-CONTEXT.md
@.planning/phases/01-scaffold-schema-server-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config validation + auth middleware + CORS</name>
  <files>
    server/src/config.ts
    server/src/middleware/auth.ts
    server/src/app.ts
    server/src/index.ts
  </files>
  <action>
**server/src/config.ts** — Validates env vars at module load time (synchronously, before any routes):

```typescript
import 'dotenv/config'; // Must be first

// Required env vars — server will NOT start without these
const REQUIRED = ['COPILOT_ENVIRONMENT_ID', 'COPILOT_AGENT_SCHEMA_NAME'] as const;

for (const key of REQUIRED) {
  if (!process.env[key]) {
    console.error(`[config] FATAL: Missing required environment variable: ${key}`);
    console.error(`[config] Copy server/.env.example to server/.env and fill in values.`);
    process.exit(1);
  }
}

export const config = {
  COPILOT_ENVIRONMENT_ID: process.env.COPILOT_ENVIRONMENT_ID!,
  COPILOT_AGENT_SCHEMA_NAME: process.env.COPILOT_AGENT_SCHEMA_NAME!,
  COPILOT_TENANT_ID: process.env.COPILOT_TENANT_ID,
  COPILOT_APP_ID: process.env.COPILOT_APP_ID,
  COPILOT_CLIENT_SECRET: process.env.COPILOT_CLIENT_SECRET,
  COPILOT_STUB_TOKEN: process.env.COPILOT_STUB_TOKEN ?? '',
  // Fail-closed: AUTH_REQUIRED is TRUE unless explicitly set to the string "false"
  AUTH_REQUIRED: process.env.AUTH_REQUIRED !== 'false',
  CORS_ORIGIN: process.env.CORS_ORIGIN ?? 'http://localhost:5173',
  PORT: Number(process.env.PORT ?? 3001),
} as const;
```

**server/src/middleware/auth.ts** — Fail-closed auth stub:

```typescript
import type { Request, Response, NextFunction } from 'express';
import { config } from '../config.js';

export function authMiddleware(req: Request, res: Response, next: NextFunction): void {
  if (!config.AUTH_REQUIRED) {
    next();
    return;
  }

  if (!req.headers.authorization) {
    // TODO: Replace with real MSAL OBO token validation.
    // Real flow:
    //   1. Extract Bearer token from req.headers.authorization
    //   2. Call ConfidentialClientApplication.acquireTokenOnBehalfOf() from @azure/msal-node
    //   3. Use config.COPILOT_TENANT_ID, config.COPILOT_APP_ID, config.COPILOT_CLIENT_SECRET
    //   4. Validate JWT audience matches CopilotStudioClient.scopeFromSettings(settings)
    // Until then, all requests without Authorization header are rejected.
    console.warn('[auth] Rejected request — no Authorization header. Set AUTH_REQUIRED=false to bypass in dev.');
    res.status(401).json({ error: 'Unauthorized' });
    return;
  }

  // TODO: Validate the token — currently passes through any non-empty Authorization header
  next();
}
```

**server/src/app.ts** — Express app factory (separates app creation from server listen, enabling testing):

```typescript
import express from 'express';
import cors from 'cors';
import { config } from './config.js';
import { authMiddleware } from './middleware/auth.js';

export function createApp() {
  const app = express();

  // CORS — client origin only, never wildcard
  app.use(cors({
    origin: config.CORS_ORIGIN,
    methods: ['GET', 'POST', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
  }));

  app.use(express.json());

  // Health check — unauthenticated so dev tools can probe
  app.get('/health', (_req, res) => {
    res.json({ status: 'ok', authRequired: config.AUTH_REQUIRED });
  });

  // All /api routes require auth
  app.use('/api', authMiddleware);

  return app;
}
```

**server/src/index.ts** — Entry point. Import config FIRST so validation runs at startup:

```typescript
import './config.js'; // MUST be first — exits process if required vars missing
import { createApp } from './app.js';
import { config } from './config.js';

const app = createApp();

app.listen(config.PORT, () => {
  console.log(`[server] Running on http://localhost:${config.PORT}`);
  console.log(`[server] Auth required: ${config.AUTH_REQUIRED}`);
  console.log(`[server] CORS origin: ${config.CORS_ORIGIN}`);
});
```

Note: server/src/index.ts requires a `.env` file with at minimum `COPILOT_ENVIRONMENT_ID` and `COPILOT_AGENT_SCHEMA_NAME` set, or it will exit. Create a `server/.env` file (not committed) with test values for local dev. The `.env.example` is the template.
  </action>
  <verify>
    Create server/.env from server/.env.example with placeholder values for COPILOT_ENVIRONMENT_ID and COPILOT_AGENT_SCHEMA_NAME.
    `npm run dev --workspace=server` starts and prints "[server] Running on http://localhost:3001".
    `curl http://localhost:3001/health` returns `{"status":"ok","authRequired":true}`.
    `curl -X POST http://localhost:3001/api/chat/start` returns 401 `{"error":"Unauthorized"}` (no auth header).
    `curl -X POST -H "Authorization: Bearer test" http://localhost:3001/api/chat/start` returns 404 (auth passes, no route yet — that's correct for this plan).
  </verify>
  <done>
    Express server starts, /health responds, fail-closed auth returns 401 on missing auth header, CORS configured to specific origin.
  </done>
</task>

<task type="auto">
  <name>Task 2: ConversationStore interface + LRU InMemoryConversationStore</name>
  <files>
    server/src/store/ConversationStore.ts
    server/src/store/InMemoryStore.ts
    server/src/store/index.ts
  </files>
  <action>
**server/src/store/ConversationStore.ts** — Interface and stored shape:

```typescript
import type { NormalizedMessage } from '@copilot-chat/shared';

export interface StoredConversation {
  /** Server-generated UUID — the external conversationId sent to clients */
  externalId: string;
  /**
   * The internal Copilot SDK conversation reference.
   * Stored as unknown here because the SDK type is only imported on the server.
   * Cast to Activity[] internally when needed.
   */
  sdkConversationRef: unknown;
  /** Full message history for this conversation */
  history: NormalizedMessage[];
}

export interface ConversationStore {
  get(id: string): Promise<StoredConversation | undefined>;
  set(id: string, conversation: StoredConversation): Promise<void>;
  delete(id: string): Promise<void>;
}
```

**server/src/store/InMemoryStore.ts** — LRU-backed implementation:

```typescript
import { LRUCache } from 'lru-cache';
import type { ConversationStore, StoredConversation } from './ConversationStore.js';

/** Maximum number of active conversations in memory. LRU evicts oldest when exceeded. */
const MAX_CONVERSATIONS = 100;

export class InMemoryConversationStore implements ConversationStore {
  private cache = new LRUCache<string, StoredConversation>({ max: MAX_CONVERSATIONS });

  async get(id: string): Promise<StoredConversation | undefined> {
    return this.cache.get(id);
  }

  async set(id: string, conversation: StoredConversation): Promise<void> {
    this.cache.set(id, conversation);
  }

  async delete(id: string): Promise<void> {
    this.cache.delete(id);
  }
}
```

**server/src/store/index.ts** — Singleton export (module-level, reused across routes):

```typescript
import { InMemoryConversationStore } from './InMemoryStore.js';
import type { ConversationStore } from './ConversationStore.js';

export type { ConversationStore, StoredConversation } from './ConversationStore.js';
export { InMemoryConversationStore } from './InMemoryStore.js';

// Module-level singleton — production replacement is a drop-in
export const conversationStore: ConversationStore = new InMemoryConversationStore();
```

After creating these files, rebuild shared/ if needed and verify the server still compiles:
`npx tsc --build --noEmit` in server/ to check types.
  </action>
  <verify>
    `npx tsc --build --noEmit` in server/ exits 0 (no type errors).
    Write a quick inline smoke test in terminal:
    ```
    node --input-type=module --experimental-vm-modules &lt;&lt;'EOF'
    // Not a real test — just type-checking that imports work at runtime
    import { InMemoryConversationStore } from './server/dist/store/InMemoryStore.js';
    const s = new InMemoryConversationStore();
    await s.set('test-id', { externalId: 'test-id', sdkConversationRef: null, history: [] });
    const got = await s.get('test-id');
    console.assert(got?.externalId === 'test-id', 'store round-trip failed');
    console.log('ConversationStore smoke test passed');
    EOF
    ```
    OR simply: `npm run dev --workspace=server` starts without TypeScript errors.
  </verify>
  <done>
    ConversationStore interface and InMemoryConversationStore with LRU max=100 created and type-check clean.
    conversationStore singleton exported from server/src/store/index.ts.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `npm run dev --workspace=server` — server starts on 3001, no TypeScript errors
2. `curl http://localhost:3001/health` — returns `{"status":"ok","authRequired":true}`
3. `curl -X POST http://localhost:3001/api/chat/start` — returns 401 `{"error":"Unauthorized"}`
4. `curl -X POST -H "Authorization: Bearer stub" http://localhost:3001/api/chat/start` — returns 404 (route not found yet — correct)
5. Set `AUTH_REQUIRED=false` in server/.env, restart server:
   `curl -X POST http://localhost:3001/api/chat/start` — returns 404 (no longer 401, auth bypassed)
6. TypeScript: `cd server && npx tsc --noEmit` — exits 0
</verification>

<success_criteria>
- Express server starts with config validation (exits on missing required vars)
- AUTH_REQUIRED=true (default): requests without Authorization → 401
- AUTH_REQUIRED=false: requests without Authorization proceed to route handler
- CORS restricted to CORS_ORIGIN env var (not wildcard)
- ConversationStore interface + InMemoryConversationStore (LRU max=100) implemented
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-scaffold-schema-server-foundation/01-03-SUMMARY.md` using the summary template at @/Users/zycroft/.claude/get-shit-done/templates/summary.md
</output>
