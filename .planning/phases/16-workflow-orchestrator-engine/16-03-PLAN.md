---
phase: 16-workflow-orchestrator-engine
plan: 03
type: tdd
wave: 2
depends_on: [16-01, 16-02]
files_modified:
  - server/src/orchestrator/WorkflowOrchestrator.ts
  - server/src/orchestrator/WorkflowOrchestrator.test.ts
autonomous: true
requirements: [ORCH-01, ORCH-02, ORCH-03, ORCH-06]

must_haves:
  truths:
    - "Starting a workflow creates a WorkflowState in Redis scoped to userId and tenantId"
    - "Processing a text turn executes the full loop: load state, enrich query, Copilot call, normalize, parse, merge data, save state"
    - "Processing a card action flows through the orchestrator and produces WorkflowResponse with messages and updated state"
    - "Second turn includes first turn's collected data in the Copilot query preamble"
    - "If Copilot call fails, state is NOT saved (rollback-on-failure)"
    - "Lock is acquired before state read and released after state save (or on error)"
    - "Redis being down returns 503 (no in-memory fallback for state)"
  artifacts:
    - path: "server/src/orchestrator/WorkflowOrchestrator.ts"
      provides: "WorkflowOrchestrator service class with DI constructor"
      exports: ["WorkflowOrchestrator"]
    - path: "server/src/orchestrator/WorkflowOrchestrator.test.ts"
      provides: "Unit tests with fully mocked dependencies"
      min_lines: 150
  key_links:
    - from: "server/src/orchestrator/WorkflowOrchestrator.ts"
      to: "server/src/store/WorkflowStateStore.ts"
      via: "constructor-injected workflowStore for state persistence"
      pattern: "workflowStore\\.get|workflowStore\\.set"
    - from: "server/src/orchestrator/WorkflowOrchestrator.ts"
      to: "server/src/lock/ConversationLock.ts"
      via: "constructor-injected lock for per-conversation mutual exclusion"
      pattern: "lock\\.acquire"
    - from: "server/src/orchestrator/WorkflowOrchestrator.ts"
      to: "server/src/workflow/contextBuilder.ts"
      via: "buildContextualQuery enriches outbound Copilot queries with accumulated state"
      pattern: "buildContextualQuery"
    - from: "server/src/orchestrator/WorkflowOrchestrator.ts"
      to: "server/src/parser/structuredOutputParser.ts"
      via: "parseTurn extracts structured data from Copilot response"
      pattern: "parseTurn"
---

<objective>
TDD: WorkflowOrchestrator service class — the full per-turn orchestration loop

Purpose: Implement the core orchestrator service that manages the complete per-turn workflow loop: acquire lock, load state, enrich query with context, call Copilot, normalize activities, parse structured output, merge collected data, save state, release lock, return WorkflowResponse. This is the heart of ORCH-01, ORCH-02, ORCH-03, and ORCH-06.

Output: WorkflowOrchestrator class with processTurn() and processCardAction() methods, fully unit tested with mocked dependencies.
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-workflow-orchestrator-engine/16-RESEARCH.md
@.planning/phases/16-workflow-orchestrator-engine/16-01-SUMMARY.md
@.planning/phases/16-workflow-orchestrator-engine/16-02-SUMMARY.md
@server/src/store/WorkflowStateStore.ts
@server/src/store/ConversationStore.ts
@server/src/lock/ConversationLock.ts
@server/src/orchestrator/types.ts
@server/src/workflow/contextBuilder.ts
@server/src/workflow/workflowDefinition.ts
@server/src/parser/structuredOutputParser.ts
@server/src/normalizer/activityNormalizer.ts
@server/src/copilot.ts
@server/src/utils/errorDetection.ts
@shared/src/schemas/workflowState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD WorkflowOrchestrator — core service with processTurn and processCardAction</name>
  <files>
    server/src/orchestrator/WorkflowOrchestrator.test.ts
    server/src/orchestrator/WorkflowOrchestrator.ts
  </files>
  <action>
RED phase: Create `server/src/orchestrator/WorkflowOrchestrator.test.ts` with fully mocked dependencies.

**Test setup:** Create mock implementations for all dependencies:
- `mockWorkflowStore`: Mock WorkflowStateStore with get/set/delete as vi.fn()
- `mockConversationStore`: Mock ConversationStore with get/set as vi.fn()
- `mockLock`: Mock ConversationLock where acquire returns a vi.fn() release function
- `mockCopilotClient`: Mock object with sendActivityStreaming returning an async generator of Activity[]
  - Use a helper: `async function* mockStream(activities: Activity[]) { for (const a of activities) yield a; }`
  - Also mock startConversationStreaming for session start
- Return realistic Activity objects with text and from.role='bot' so normalizeActivities produces valid NormalizedMessage[]

**Tests to write:**

1. **`startSession creates initial WorkflowState scoped to userId and tenantId` (ORCH-01)**
   - Call orchestrator.startSession({ conversationId, userId, tenantId })
   - Verify workflowStore.set called with state containing userId, tenantId, step='initial', turnCount=0, status='active'
   - Verify conversationStore.set called to create the conversation record

2. **`processTurn executes full loop and returns WorkflowResponse` (ORCH-02)**
   - Set up mockWorkflowStore.get to return an existing state
   - Set up mockCopilotClient to return activity with text response
   - Call orchestrator.processTurn({ conversationId, text, userId, tenantId })
   - Verify: lock.acquire called, workflowStore.get called, copilotClient.sendActivityStreaming called, workflowStore.set called with updated turnCount, lock release called
   - Verify response shape: has messages, parsedTurn, workflowState, progress, turnMeta, latencyMs

3. **`processTurn enriches query with accumulated context` (ORCH-06)**
   - Set up state with collectedData: { name: 'Alice' }
   - Call processTurn with text 'next question'
   - Verify the activity sent to copilotClient has text containing the context preamble (Phase: ..., Collected data: {"name":"Alice"}, Turn number: ...)

4. **`processTurn merges new data into collectedData` (ORCH-06)**
   - Set up existing state with collectedData: { name: 'Alice' }
   - Mock copilot to return structured response with data: { age: 30 }
   - Call processTurn
   - Verify workflowStore.set called with collectedData containing BOTH { name: 'Alice', age: 30 } (shallow merge)
   - Verify turnMeta.collectedThisTurn is { age: 30 } (delta only)
   - Verify turnMeta.stateChanged is true

5. **`processTurn with passthrough response does not modify collectedData`**
   - Set up existing state with collectedData: { name: 'Alice' }
   - Mock copilot to return plain text (no structured data)
   - Call processTurn
   - Verify collectedData remains { name: 'Alice' }
   - Verify turnMeta.stateChanged is false
   - Verify turnMeta.collectedThisTurn is {}

6. **`processCardAction flows through orchestrator` (ORCH-03)**
   - Set up existing state
   - Call orchestrator.processCardAction({ conversationId, cardId, userSummary, submitData, userId, tenantId })
   - Verify: lock acquired, copilotClient.sendActivityStreaming called with activity containing submitData as value, response includes messages and updated workflowState

7. **`processTurn rolls back on Copilot failure — state NOT saved`**
   - Set up existing state
   - Mock copilotClient to throw Error('Copilot timeout')
   - Call processTurn, expect it to throw
   - Verify workflowStore.set was NOT called (state not saved)
   - Verify lock release WAS called (cleanup in finally)

8. **`processTurn acquires lock before state read and releases after save`**
   - Track call order via vi.fn() implementations that record when they're called
   - Verify order: lock.acquire → workflowStore.get → [copilot/normalize/parse] → workflowStore.set → release()

9. **`processTurn creates initial state if none exists`**
   - Set up workflowStore.get to return undefined (new conversation)
   - Call processTurn
   - Verify workflowStore.set called with initial state (step='initial', turnCount=1, userId, tenantId)

10. **`processTurn progress reflects step position in definition`**
    - Set up state with step='confirm' (index 3 in default 5-step definition)
    - Call processTurn
    - Verify response.progress.percentComplete = 60 (3/5 * 100)
    - Verify response.progress.totalSteps = 5

GREEN phase: Create `server/src/orchestrator/WorkflowOrchestrator.ts`:

```typescript
export class WorkflowOrchestrator {
  private readonly workflowStore: WorkflowStateStore;
  private readonly conversationStore: ConversationStore;
  private readonly copilotClient: CopilotStudioClient;
  private readonly lock: ConversationLock;
  private readonly definition: WorkflowDefinition;
  private readonly contextConfig?: ContextBuilderConfig;

  constructor(deps: {
    workflowStore: WorkflowStateStore;
    conversationStore: ConversationStore;
    copilotClient: CopilotStudioClient;
    lock: ConversationLock;
    config?: OrchestratorConfig;
  }) { ... }
```

**startSession(params: { conversationId, userId, tenantId }):**
1. Create initial WorkflowState: `{ step: 'initial', collectedData: {}, turnCount: 0, status: 'active', userId, tenantId }`
2. Save to workflowStore
3. Create conversation record in conversationStore (same as current orchestrate.ts line 53-62)
4. Return the initial state

**processTurn(params: ProcessTurnParams): Promise&lt;WorkflowResponse&gt;:**
1. `const release = await this.lock.acquire(params.conversationId)`
2. try:
   a. `let state = await this.workflowStore.get(params.conversationId)`
   b. If no state, create initial: `{ step: 'initial', collectedData: {}, turnCount: 0, status: 'active', userId: params.userId, tenantId: params.tenantId }`
   c. Build enriched query: `const { query } = buildContextualQuery(params.text, state, this.contextConfig)`
   d. Create Activity: `{ type: 'message', text: query }`
   e. Collect activities from `copilotClient.sendActivityStreaming(activity)` and measure latency
   f. `const messages = normalizeActivities(collectedActivities)`
   g. `const parsedTurn = await parseTurn(messages)`
   h. Compute delta: if parsedTurn.kind === 'structured' && parsedTurn.data, extract new data fields
   i. Merge: `const mergedData = { ...(state.collectedData ?? {}), ...newData }`
   j. Compute step: if parsedTurn.nextAction maps to a definition step, update; otherwise keep current
      - Map nextAction to step: 'ask' -> 'gather_info', 'research' -> 'research', 'confirm' -> 'confirm', 'complete' -> 'complete'
      - If nextAction is null (passthrough), keep state.step unchanged
   k. Updated state: `{ ...state, collectedData: mergedData, turnCount: state.turnCount + 1, step: updatedStep, currentPhase: updatedStep }`
   l. `await this.workflowStore.set(params.conversationId, updatedState)` — this is the ONLY save point (rollback-on-failure)
   m. Update conversation history in conversationStore
   n. Compute progress via getStepProgress(updatedStep, this.definition)
   o. Build turnMeta: { turnNumber: updatedState.turnCount, stateChanged: Object.keys(newData).length > 0, collectedThisTurn: newData }
   p. Return WorkflowResponse
3. catch: re-throw (state never saved = clean rollback)
4. finally: `await release()`

**processCardAction(params: ProcessCardActionParams): Promise&lt;WorkflowResponse&gt;:**
Same flow as processTurn but:
- Activity has `{ type: 'message', text: params.userSummary, value: { ...params.submitData, cardId: params.cardId } }`
- No context enrichment (card actions are self-contained)
- Still acquires lock, loads state, normalizes, parses, merges, saves

Commit RED: `test(16-03): add failing tests for WorkflowOrchestrator`
Commit GREEN: `feat(16-03): implement WorkflowOrchestrator service class`
  </action>
  <verify>
cd server && npx vitest run src/orchestrator/WorkflowOrchestrator.test.ts --reporter=verbose
All 10 tests pass. No regressions: cd server && npx vitest run
  </verify>
  <done>WorkflowOrchestrator implements the full per-turn loop with DI constructor, lock-protected state read-modify-write, context enrichment, structured output parsing, data accumulation across turns, and rollback-on-failure. All 10 tests pass with fully mocked dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Export orchestrator singleton and verify integration</name>
  <files>
    server/src/orchestrator/index.ts
  </files>
  <action>
Create `server/src/orchestrator/index.ts` barrel export:

```typescript
import { WorkflowOrchestrator } from './WorkflowOrchestrator.js';
import { workflowStateStore, conversationStore, conversationLock } from '../store/index.js';
import { copilotClient } from '../copilot.js';
import { DEFAULT_WORKFLOW_DEFINITION } from '../workflow/workflowDefinition.js';

export { WorkflowOrchestrator } from './WorkflowOrchestrator.js';
export type {
  WorkflowResponse,
  ProcessTurnParams,
  ProcessCardActionParams,
  OrchestratorConfig,
  WorkflowProgress,
  TurnMeta,
} from './types.js';

/**
 * Singleton WorkflowOrchestrator — pre-wired with store, lock, and Copilot client.
 *
 * Consumed by route handlers in Phase 17.
 * Uses default workflow definition; can be reconfigured via constructor if needed.
 *
 * ORCH-02
 */
export const orchestrator = new WorkflowOrchestrator({
  workflowStore: workflowStateStore,
  conversationStore,
  copilotClient,
  lock: conversationLock,
  config: {
    workflowDefinition: DEFAULT_WORKFLOW_DEFINITION,
  },
});
```

This gives Phase 17 a ready-to-use `orchestrator` singleton.

Verify TypeScript compilation: `cd server && npx tsc --noEmit`

Commit: `feat(16-03): export orchestrator singleton for route integration`
  </action>
  <verify>
cd server && npx tsc --noEmit
cd server && npx vitest run
npm run lint
  </verify>
  <done>Orchestrator singleton exported with all dependencies pre-wired. Phase 17 can import `orchestrator` from `../orchestrator/index.js` and call processTurn/processCardAction directly from route handlers.</done>
</task>

</tasks>

<verification>
- `cd server && npx vitest run` — all tests pass (existing + 10 new orchestrator tests)
- `cd server && npx tsc --noEmit` — TypeScript compiles
- `npm run lint` — no lint errors
- Orchestrator test coverage: startSession, processTurn full loop, context enrichment, data merging, card action flow, rollback on failure, lock ordering, initial state creation, progress computation
- Orchestrator singleton ready for Phase 17 route integration
</verification>

<success_criteria>
- WorkflowOrchestrator.processTurn executes the complete per-turn loop
- WorkflowOrchestrator.processCardAction handles card submissions through the workflow
- Context accumulation works: turn N's data appears in turn N+1's Copilot query
- Rollback on failure: if Copilot call fails, state is not saved
- Lock protects entire read-modify-write cycle
- All 10+ tests pass with mocked dependencies
- Orchestrator singleton exported for Phase 17 consumption
</success_criteria>

<output>
After completion, create `.planning/phases/16-workflow-orchestrator-engine/16-03-SUMMARY.md`
</output>
