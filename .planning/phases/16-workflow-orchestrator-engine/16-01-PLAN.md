---
phase: 16-workflow-orchestrator-engine
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - server/src/store/RedisWorkflowStateStore.ts
  - server/src/store/RedisWorkflowStateStore.test.ts
  - server/src/lock/ConversationLock.ts
  - server/src/lock/ConversationLock.test.ts
  - server/src/store/factory.ts
  - server/src/store/index.ts
autonomous: true
requirements: [ORCH-05, ORCH-07]

must_haves:
  truths:
    - "Workflow state persists in Redis and survives server restart"
    - "Every Redis write resets the 24-hour TTL (sliding window)"
    - "Only one request can process a given conversationId at a time"
    - "Lock releases safely even if the holder's lock expired and was re-acquired"
    - "Factory selects Redis store when REDIS_URL is set, InMemory otherwise"
  artifacts:
    - path: "server/src/store/RedisWorkflowStateStore.ts"
      provides: "Redis-backed WorkflowStateStore with 24h sliding TTL"
      exports: ["RedisWorkflowStateStore"]
    - path: "server/src/lock/ConversationLock.ts"
      provides: "Per-conversation Redis lock with SET NX PX and Lua release"
      exports: ["ConversationLock", "RedisConversationLock", "InMemoryConversationLock", "ConversationLockError"]
    - path: "server/src/store/factory.ts"
      provides: "createWorkflowStateStore factory function"
      exports: ["createWorkflowStateStore"]
    - path: "server/src/store/index.ts"
      provides: "Updated workflowStateStore singleton via factory"
      exports: ["workflowStateStore"]
  key_links:
    - from: "server/src/store/factory.ts"
      to: "server/src/store/RedisWorkflowStateStore.ts"
      via: "createWorkflowStateStore selects Redis when REDIS_URL set"
      pattern: "new RedisWorkflowStateStore"
    - from: "server/src/lock/ConversationLock.ts"
      to: "ioredis"
      via: "SET NX PX for lock acquisition, eval for Lua release script"
      pattern: "redis\\.set.*NX.*PX"
---

<objective>
TDD: Redis workflow state store with 24h sliding TTL and per-conversation locking

Purpose: Provide persistent storage for workflow state (ORCH-05) and per-conversation sequential processing via Redis locks (ORCH-07). These are the infrastructure building blocks the WorkflowOrchestrator service (Plan 16-03) depends on.

Output: RedisWorkflowStateStore, ConversationLock interface + Redis/InMemory implementations, updated factory and singleton.
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-workflow-orchestrator-engine/16-RESEARCH.md
@server/src/store/RedisStore.ts
@server/src/store/WorkflowStateStore.ts
@server/src/store/InMemoryWorkflowStateStore.ts
@server/src/store/factory.ts
@server/src/store/index.ts
@server/src/utils/errorDetection.ts
@shared/src/schemas/workflowState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD RedisWorkflowStateStore with 24h sliding TTL</name>
  <files>
    server/src/store/RedisWorkflowStateStore.test.ts
    server/src/store/RedisWorkflowStateStore.ts
  </files>
  <action>
RED phase: Create `server/src/store/RedisWorkflowStateStore.test.ts` with tests using ioredis-mock (same pattern as `server/src/store/__tests__/RedisStore.test.ts`):

Tests to write:
1. `get() returns undefined for non-existent key` — verify returns undefined
2. `set() and get() round-trip correctly` — set a WorkflowState, get it back, verify all fields
3. `set() applies TTL (sliding window)` — after set, verify key has TTL via redis.ttl() (should be ~86400s)
4. `set() resets TTL on update (sliding window)` — set, wait/verify TTL, set again, verify TTL is reset to full 86400
5. `delete() removes state` — set, delete, verify get returns undefined
6. `get() validates with WorkflowStateSchema on deserialization` — store raw JSON with extra/malformed fields, verify Zod validation handles it

GREEN phase: Create `server/src/store/RedisWorkflowStateStore.ts`:
- Import Redis from ioredis, WorkflowStateSchema from @copilot-chat/shared
- Use key prefix `wf:` (distinct from `conv:` used by RedisConversationStore)
- `get(conversationId)`: GET `wf:{conversationId}`, return undefined if null, otherwise JSON.parse + WorkflowStateSchema.parse()
- `set(conversationId, state)`: SET `wf:{conversationId}` JSON.stringify(state) EX ttlSeconds — the EX flag resets TTL on every write (sliding window per user decision)
- `delete(conversationId)`: DEL `wf:{conversationId}`
- Constructor takes `(redis: Redis, ttlSeconds: number)` — same pattern as RedisConversationStore

Follow the exact same serialization/validation pattern as RedisConversationStore in `server/src/store/RedisStore.ts`.

Commit RED: `test(15-01): add failing tests for RedisWorkflowStateStore`
Commit GREEN: `feat(15-01): implement RedisWorkflowStateStore with sliding TTL`
  </action>
  <verify>
cd server && npx vitest run src/store/RedisWorkflowStateStore.test.ts --reporter=verbose
All 6 tests pass. No regressions in existing tests: `cd server && npx vitest run`
  </verify>
  <done>RedisWorkflowStateStore implements WorkflowStateStore interface with Redis persistence, 24h sliding TTL on every write, and Zod validation on deserialization</done>
</task>

<task type="auto">
  <name>Task 2: TDD ConversationLock with Redis SET NX PX and Lua release</name>
  <files>
    server/src/lock/ConversationLock.test.ts
    server/src/lock/ConversationLock.ts
  </files>
  <action>
RED phase: Create `server/src/lock/ConversationLock.test.ts` with tests using ioredis-mock:

Tests to write:
1. `acquire() returns a release function` — acquire lock, verify release is a function
2. `acquire() sets NX key in Redis` — acquire, verify key exists in Redis
3. `release() removes the key` — acquire, release, verify key gone
4. `acquire() throws ConversationLockError when lock already held` — acquire once, try again, expect ConversationLockError
5. `release() is safe when lock expired (token mismatch)` — acquire, manually delete key from Redis (simulating expiry), release should log warning but not throw
6. `InMemoryConversationLock acquire/release works` — test the in-memory fallback for local dev/CI

GREEN phase: Create `server/src/lock/ConversationLock.ts`:

```typescript
export interface ConversationLock {
  acquire(conversationId: string): Promise<() => Promise<void>>;
}
```

`ConversationLockError` class extends Error with `conversationId` property.

`RedisConversationLock` implementation:
- Constructor takes `(redis: Redis, lockTtlMs?: number)` — default 10000ms (10s)
- Lock key prefix: `lock:conv:`
- `acquire(conversationId)`:
  1. Generate token via `uuid.v4()`
  2. `redis.set(key, token, 'NX', 'PX', lockTtlMs)` — NX = only if not exists, PX = TTL in ms
  3. If result !== 'OK', throw `new ConversationLockError(conversationId)`
  4. Return async release function that runs the Lua script:
     ```
     if redis.call("get", KEYS[1]) == ARGV[1] then
       return redis.call("del", KEYS[1])
     else
       return 0
     end
     ```
  5. If Lua returns 0, log warning: `[lock] Token mismatch on release for {conversationId} — lock may have expired`

`InMemoryConversationLock` implementation (for local dev when no Redis):
- Uses a `Set<string>` of held conversationIds
- acquire: check set, add if absent, throw if present
- release: remove from set

Commit RED: `test(16-01): add failing tests for ConversationLock`
Commit GREEN: `feat(16-01): implement ConversationLock with Redis SET NX PX`
  </action>
  <verify>
cd server && npx vitest run src/lock/ConversationLock.test.ts --reporter=verbose
All 6 tests pass. No regressions: `cd server && npx vitest run`
  </verify>
  <done>ConversationLock interface with Redis and InMemory implementations. Redis version uses SET NX PX for atomic acquisition and Lua script for safe token-verified release. Orphan protection via lock TTL (10s default).</done>
</task>

<task type="auto">
  <name>Task 3: Update store factory and singleton to use Redis for workflow state</name>
  <files>
    server/src/store/factory.ts
    server/src/store/index.ts
  </files>
  <action>
Update `server/src/store/factory.ts`:
1. Import `RedisWorkflowStateStore` and `InMemoryWorkflowStateStore`
2. Import `WorkflowStateStore` type
3. Import `RedisConversationLock`, `InMemoryConversationLock`, and `ConversationLock` type
4. Add `createWorkflowStateStore(): WorkflowStateStore` function:
   - If `config.REDIS_URL` (redisClient exists): `return new RedisWorkflowStateStore(getRedisClient()!, config.REDIS_TTL)`
   - Else: `return new InMemoryWorkflowStateStore()`
   - Add logging matching existing pattern: `[STORE] Redis detected. Using RedisWorkflowStateStore.` or `[STORE] Using InMemoryWorkflowStateStore.`
5. Add `createConversationLock(): ConversationLock` function:
   - If redisClient exists: `return new RedisConversationLock(getRedisClient()!)`
   - Else: `return new InMemoryConversationLock()`
   - Add logging: `[LOCK] Redis detected. Using RedisConversationLock.` or `[LOCK] Using InMemoryConversationLock.`

Update `server/src/store/index.ts`:
1. Import `createWorkflowStateStore` and `createConversationLock` from factory
2. Replace `export const workflowStateStore = new InMemoryWorkflowStateStore();` with `export const workflowStateStore = createWorkflowStateStore();`
3. Add `export const conversationLock = createConversationLock();`
4. Remove the direct `InMemoryWorkflowStateStore` import (now handled by factory)
5. Add type exports: `export type { ConversationLock } from '../lock/ConversationLock.js';`

Commit: `feat(16-01): update store factory for Redis workflow state and conversation lock`
  </action>
  <verify>
cd server && npx vitest run --reporter=verbose
All existing tests pass (no regressions). TypeScript compiles: `cd server && npx tsc --noEmit`
  </verify>
  <done>Factory pattern extended to create both WorkflowStateStore and ConversationLock singletons. REDIS_URL drives backend selection for both, matching the existing ConversationStore pattern. workflowStateStore singleton now uses Redis when available.</done>
</task>

</tasks>

<verification>
- `cd server && npx vitest run` — all tests pass (existing + new RedisWorkflowStateStore + ConversationLock tests)
- `cd server && npx tsc --noEmit` — TypeScript compiles without errors
- RedisWorkflowStateStore tests verify sliding TTL, round-trip serialization, and Zod validation
- ConversationLock tests verify mutual exclusion, safe release on expired lock, and token verification
- Factory correctly selects Redis or InMemory based on REDIS_URL
- `npm run lint` — no new lint errors
</verification>

<success_criteria>
- RedisWorkflowStateStore persists WorkflowState to Redis with 24h sliding TTL
- ConversationLock prevents concurrent processing of the same conversationId
- Lock release uses Lua script to verify token ownership before DEL
- Factory selects Redis or InMemory implementations based on REDIS_URL
- All tests pass, zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/16-workflow-orchestrator-engine/16-01-SUMMARY.md`
</output>
