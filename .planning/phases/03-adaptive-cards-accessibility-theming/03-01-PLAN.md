---
phase: 03-adaptive-cards-accessibility-theming
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - server/src/routes/chat.ts
  - server/src/allowlist/cardActionAllowlist.ts
  - server/src/allowlist/cardActionAllowlist.test.ts
autonomous: true
requirements: [SERV-04, SERV-07, SERV-08, SERV-12]

must_haves:
  truths:
    - "POST /api/chat/card-action with an allowed action type returns 200 and normalized bot messages"
    - "POST /api/chat/card-action with a disallowed action type returns 403 without calling Copilot"
    - "POST /api/chat/card-action with Action.OpenUrl and an allowed domain returns 200"
    - "POST /api/chat/card-action with Action.OpenUrl and a disallowed domain returns 403"
    - "Unit tests for the allowlist validator all pass via npm test in server/"
  artifacts:
    - path: "server/src/allowlist/cardActionAllowlist.ts"
      provides: "Pure allowlist validator function (no side effects)"
      exports: ["validateCardAction"]
    - path: "server/src/allowlist/cardActionAllowlist.test.ts"
      provides: "Vitest unit tests for the validator"
      min_lines: 40
    - path: "server/src/routes/chat.ts"
      provides: "POST /api/chat/card-action route using the validator"
      contains: "/card-action"
  key_links:
    - from: "server/src/routes/chat.ts"
      to: "server/src/allowlist/cardActionAllowlist.ts"
      via: "import validateCardAction"
      pattern: "validateCardAction"
    - from: "server/src/routes/chat.ts"
      to: "shared/src/schemas/api.ts"
      via: "CardActionRequestSchema.safeParse"
      pattern: "CardActionRequestSchema"
---

<objective>
Implement POST /api/chat/card-action with server-side action allowlist validation using TDD. The allowlist validator is a pure function — test it first, then wire it into the Express route.

Purpose: SERV-04 (card-action route), SERV-07 (action type allowlist), SERV-08 (OpenUrl domain allowlist), SERV-12 (unit tests for the validator).
Output: `cardActionAllowlist.ts` pure validator + Vitest tests + `/api/chat/card-action` route.
</objective>

<execution_context>
@/Users/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-adaptive-cards-accessibility-theming/03-CONTEXT.md
@.planning/phases/03-adaptive-cards-accessibility-theming/03-RESEARCH.md
@.planning/phases/02-text-chat-end-to-end/02-02-SUMMARY.md
@server/src/routes/chat.ts
@server/src/normalizer/activityNormalizer.ts
@shared/src/schemas/api.ts
</context>

<feature>
  <name>Card Action Allowlist Validator</name>
  <files>
    server/src/allowlist/cardActionAllowlist.ts
    server/src/allowlist/cardActionAllowlist.test.ts
  </files>
  <behavior>
    Pure function `validateCardAction(submitData: Record<string, unknown>): { ok: boolean; reason?: string }`

    Allowlist logic:
    - ALLOWED_ACTION_TYPES = ["Action.Submit"] (hardcoded constant, configurable via env ALLOWED_ACTION_TYPES if set)
    - ALLOWED_DOMAINS = ["copilot.microsoft.com", "microsoft.com"] (hardcoded, configurable via env ALLOWED_DOMAINS if set)

    Cases:
    - submitData.action = "Action.Submit" → { ok: true }
    - submitData.action = "Action.OpenUrl", submitData.url = "https://copilot.microsoft.com/foo" → { ok: true }
    - submitData.action = "Action.OpenUrl", submitData.url = "https://evil.com" → { ok: false, reason: "Domain not allowed: evil.com" }
    - submitData.action = "Action.OpenUrl", submitData.url = "not-a-url" → { ok: false, reason: "Invalid URL" }
    - submitData.action = "Action.Execute" → { ok: false, reason: "Action type not allowed: Action.Execute" }
    - submitData.action = undefined → { ok: false, reason: "Missing action type" }
    - submitData.action = 42 (not a string) → { ok: false, reason: "Action type must be a string" }
  </behavior>
  <implementation>
    After tests pass (RED→GREEN):
    - Extract ALLOWED_ACTION_TYPES and ALLOWED_DOMAINS as module-level constants
    - For OpenUrl: use new URL(submitData.url) inside try/catch to validate URL format; check .hostname against ALLOWED_DOMAINS (exact match or suffix match for subdomains)
    - Domain suffix check: hostname === domain || hostname.endsWith('.' + domain)
    - Return { ok: false, reason: string } for all failure cases; { ok: true } for pass
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: TDD — card action allowlist validator (RED→GREEN→REFACTOR)</name>
  <files>
    server/src/allowlist/cardActionAllowlist.ts
    server/src/allowlist/cardActionAllowlist.test.ts
  </files>
  <action>
    RED phase: Create `server/src/allowlist/cardActionAllowlist.test.ts` with Vitest tests for all 7 behavioral cases listed in the feature block above. Import `validateCardAction` from `./cardActionAllowlist.js`. Run `npm test --workspace=server` — tests MUST fail (function not yet implemented).

    Commit: `test(03-01): add failing tests for card action allowlist validator`

    GREEN phase: Create `server/src/allowlist/cardActionAllowlist.ts` implementing `validateCardAction`. Logic:
    1. If `submitData.action` is undefined → `{ ok: false, reason: "Missing action type" }`
    2. If `submitData.action` is not a string → `{ ok: false, reason: "Action type must be a string" }`
    3. If action type not in ALLOWED_ACTION_TYPES and not "Action.OpenUrl" → `{ ok: false, reason: \`Action type not allowed: ${action}\` }`
    4. If action === "Action.OpenUrl":
       a. Try `new URL(String(submitData.url))` — catch → `{ ok: false, reason: "Invalid URL" }`
       b. Check hostname: `hostname === domain || hostname.endsWith('.' + domain)` for each domain in ALLOWED_DOMAINS
       c. If no match → `{ ok: false, reason: \`Domain not allowed: ${hostname}\` }`
       d. If match → `{ ok: true }`
    5. Otherwise (e.g. "Action.Submit") → `{ ok: true }`

    Run `npm test --workspace=server` — all tests MUST pass.

    Commit: `feat(03-01): implement card action allowlist validator`

    REFACTOR (if needed): Extract type `AllowlistResult = { ok: boolean; reason?: string }` and export it. Run tests again — must still pass.

    Commit: `refactor(03-01): extract AllowlistResult type` (only if refactor was done)
  </action>
  <verify>
    npm test --workspace=server
    All tests pass with 0 failures. The cardActionAllowlist.test.ts file covers all 7 behavioral cases.
  </verify>
  <done>
    `server/src/allowlist/cardActionAllowlist.ts` exports `validateCardAction` function and `AllowlistResult` type.
    `server/src/allowlist/cardActionAllowlist.test.ts` has ≥7 test cases, all passing.
    `npm test --workspace=server` exits 0.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire POST /api/chat/card-action route into Express</name>
  <files>server/src/routes/chat.ts</files>
  <action>
    Add the `/card-action` route to `server/src/routes/chat.ts` after the existing `/send` route. The route already has `CardActionRequestSchema` available from `@copilot-chat/shared` (already imported from shared schemas — add it to the import if not present).

    Route logic:
    1. Parse body with `CardActionRequestSchema.safeParse(req.body)` → 400 if invalid
    2. Look up conversation with `conversationStore.get(conversationId)` → 404 if not found
    3. Call `validateCardAction(submitData)` — if `!result.ok` → return `res.status(403).json({ error: result.reason })`
    4. Build activity:
       ```ts
       const cardActivity: Activity = {
         type: ActivityTypes.Message,
         text: userSummary,
         value: submitData,
       } as Activity;
       ```
    5. Call `copilotClient.sendActivityStreaming(cardActivity)`, collect, normalize with `normalizeActivities()`
    6. Update `conversationStore` history (same pattern as `/send`)
    7. Return `res.status(200).json({ conversationId, messages })` — shape matches `CardActionResponseSchema`

    Add import: `import { CardActionRequestSchema } from '@copilot-chat/shared';`
    Add import: `import { validateCardAction } from '../allowlist/cardActionAllowlist.js';`

    Run `cd server && npx tsc --noEmit` — must exit 0.
    Run `npm test --workspace=server` — existing tests still pass.
  </action>
  <verify>
    cd server && npx tsc --noEmit
    npm test --workspace=server
    grep -n "card-action" server/src/routes/chat.ts
  </verify>
  <done>
    `server/src/routes/chat.ts` contains a `chatRouter.post('/card-action', ...)` handler.
    Handler validates with CardActionRequestSchema, calls validateCardAction, returns 403 on disallowed actions.
    TypeScript compiles clean. All server tests pass.
  </done>
</task>

</tasks>

<verification>
- npm test --workspace=server exits 0 with all allowlist tests passing
- server/src/allowlist/cardActionAllowlist.ts exports validateCardAction
- server/src/routes/chat.ts has /card-action route that returns 403 for disallowed action types
- cd server && npx tsc --noEmit exits 0
</verification>

<success_criteria>
- SERV-04: POST /api/chat/card-action route exists and handles the full card-action request lifecycle
- SERV-07: Action type allowlist enforced — disallowed types return 403 before any Copilot call
- SERV-08: OpenUrl domain allowlist enforced — disallowed domains return 403
- SERV-12: Unit tests for the allowlist validator pass (≥7 test cases covering all behavioral variants)
</success_criteria>

<output>
After completion, create `.planning/phases/03-adaptive-cards-accessibility-theming/03-01-SUMMARY.md`
</output>
