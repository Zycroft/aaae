# v1.5 Milestone Prompt — Workflow Orchestrator + Structured Output Parsing

## Priority: P1 (Core architectural evolution)

## Context

This is a React + Express monorepo chat app connected to Microsoft Copilot Studio. Currently the Node server is a **stateless proxy** — it forwards user messages to Copilot, normalizes responses (text + Adaptive Cards), and returns them. It does not interpret, route, or control the conversation.

The target architecture (`p1.1 flow architecture.md`) requires the Node backend to become a **Workflow Orchestrator** that:
1. Sends research queries **with constraints** to Copilot (not raw user text)
2. Parses **structured output (JSON schema)** from Copilot's responses
3. Updates **workflow state** in a persistent store
4. Determines what to ask or show the user next based on Copilot's structured response

**Critical design input:** The workflows are **dynamic and AI-driven** — Copilot Studio determines the next step based on context, not a hardcoded sequence. The orchestrator's job is to:
- Enrich queries with collected context before sending to Copilot
- Parse Copilot's response to extract structured data, next-step signals, and display content
- Maintain a running context object that accumulates across turns
- Present the appropriate UI based on what Copilot returns (text prompt, Adaptive Card, progress update, final result)

This milestone assumes:
- v1.2 (Authentication) provides `req.user` with identity claims
- v1.3 (Channel Spike) has concluded with a channel recommendation (SDK or Direct Line)
- v1.4 (Redis State Store) provides persistent conversation state with the expanded model

## What to Build

### Structured Output Parser (`server/src/parser/`)

The parser sits between the activity normalizer and the orchestrator. It extracts structured signals from Copilot's responses.

**`server/src/parser/structuredOutputParser.ts`**

- Input: `NormalizedMessage[]` from a single Copilot turn
- Output:
  ```typescript
  interface ParsedTurn {
    // Structured data extracted from the response
    data: Record<string, unknown> | null;

    // AI-driven flow signals
    nextAction: 'ask' | 'research' | 'confirm' | 'complete' | 'error' | null;
    nextPrompt: string | null;        // What to ask/show the user next

    // Display content (pass through to client)
    displayMessages: NormalizedMessage[];

    // Metadata
    confidence: number | null;         // If Copilot provides a confidence score
    citations: string[];               // Extracted citation URLs
    parseErrors: string[];             // Non-fatal parsing issues
  }
  ```
- Parsing strategy (try in order):
  1. Check `activity.value` or `activity.entities` for structured JSON (Direct Line)
  2. Check for JSON code blocks in text responses (```json ... ```)
  3. Check for Adaptive Card `data` fields that contain structured payloads
  4. Fall through: treat as unstructured text (set `data: null`, `nextAction: null`)
- Use Zod schemas to validate extracted JSON against expected shapes
- Never throw on parse failure — return `parseErrors` array and let the orchestrator decide how to handle

**`shared/src/schemas/workflow.ts`**

Define the structured output contract that Copilot agents should conform to:
```typescript
// What we expect Copilot to return in structured responses
const CopilotStructuredOutputSchema = z.object({
  action: z.enum(['ask', 'research', 'confirm', 'complete', 'error']).optional(),
  prompt: z.string().optional(),           // Next question/instruction for the user
  data: z.record(z.unknown()).optional(),   // Collected/computed data
  confidence: z.number().min(0).max(1).optional(),
  citations: z.array(z.string().url()).optional(),
}).passthrough();  // Allow additional fields we don't know about yet
```

### Workflow Orchestrator (`server/src/workflow/`)

**`server/src/workflow/WorkflowOrchestrator.ts`**

The orchestrator is a stateful service that manages conversation flow:

```typescript
class WorkflowOrchestrator {
  // Start a new workflow session
  async startWorkflow(userId: string, tenantId: string, workflowId?: string): Promise<WorkflowSession>;

  // Process a user's input through the workflow
  async processUserInput(
    conversationId: string,
    input: UserInput
  ): Promise<WorkflowResponse>;

  // Process a card action through the workflow
  async processCardAction(
    conversationId: string,
    cardId: string,
    submitData: Record<string, unknown>
  ): Promise<WorkflowResponse>;
}
```

- `UserInput` is either text or card submit data
- `WorkflowResponse` contains:
  ```typescript
  interface WorkflowResponse {
    messages: NormalizedMessage[];       // Display content for client
    workflowState: {
      status: 'active' | 'completed' | 'error';
      currentPhase: string | null;      // Human-readable phase name
      collectedData: Record<string, unknown>;  // All data gathered so far
      progress: number | null;          // 0-1 if estimable
    };
  }
  ```

**Core orchestration loop (single turn):**

1. Load conversation state from Redis store
2. Build enriched Copilot query:
   - Include workflow context: what data has been collected, what phase we're in
   - Include the user's input (text or card submit data)
   - Include any system constraints or instructions
3. Send enriched query to Copilot (via SDK or Direct Line, per v1.3 decision)
4. Normalize response activities → `NormalizedMessage[]`
5. Parse structured output → `ParsedTurn`
6. Update workflow state:
   - Merge new `data` into `stepData`
   - Update `currentStep` based on `nextAction`
   - Append to conversation `history`
7. Save updated state to Redis store
8. Return `WorkflowResponse` to the route handler

**`server/src/workflow/contextBuilder.ts`**

Builds the enriched query sent to Copilot:

```typescript
function buildCopilotQuery(
  userInput: string,
  workflowState: StoredConversation,
  systemConstraints?: string[]
): string;
```

- Prepends workflow context as a structured preamble:
  ```
  [CONTEXT]
  Phase: {currentStep}
  Collected data: {JSON summary of stepData}
  Turn number: {history.length}
  [/CONTEXT]

  [USER INPUT]
  {user's actual message or card submit summary}
  [/USER INPUT]
  ```
- The exact format depends on how the Copilot Studio agent is configured to receive context — this should be configurable, not hardcoded
- If the Copilot agent uses system messages or a specific prompt format, adapt accordingly

### Updated API Routes

Evolve `server/src/routes/chat.ts` to use the orchestrator:

- **`POST /api/chat/start`** → delegates to `orchestrator.startWorkflow()`, returns `{ conversationId, messages, workflowState }`
- **`POST /api/chat/send`** → delegates to `orchestrator.processUserInput()`, returns `{ conversationId, messages, workflowState }`
- **`POST /api/chat/card-action`** → validates allowlist, then delegates to `orchestrator.processCardAction()`, returns `{ conversationId, messages, workflowState }`

The response schema expands to include `workflowState` — update shared schemas accordingly.

### Backward Compatibility

The orchestrator must work in **passthrough mode** when no structured output is detected:
- If `parsedTurn.data === null` and `parsedTurn.nextAction === null`, the orchestrator simply passes through the normalized messages (identical to v1.1 behavior)
- This means existing Copilot agents that return unstructured text still work
- Structured orchestration only activates when Copilot returns parseable structured data

## Constraints

- **Do NOT hardcode workflow steps.** The system is AI-driven — Copilot determines flow, the orchestrator manages state and context enrichment.
- **Do NOT modify the Copilot Studio agent configuration** as part of this milestone. The orchestrator must work with the agent as-is, with structured parsing as best-effort.
- The context builder's preamble format should be configurable (env var or config file) — different Copilot agents may expect different formats.
- All orchestrator operations must be idempotent — if a request is retried, the same state should result.
- The orchestrator must not block on structured output parsing — if parsing fails, fall through to passthrough mode.
- Keep the existing card action allowlist validation — it runs before the orchestrator.

## Success Criteria

1. User sends a message → orchestrator enriches with context → sends to Copilot → parses response → updates state → returns response with `workflowState`
2. Structured JSON in Copilot responses is extracted and stored in `stepData`
3. `workflowState` is returned in every API response (client can use it or ignore it)
4. Passthrough mode: when Copilot returns plain text, behavior is identical to v1.1
5. Context enrichment: subsequent turns include previously collected data in the Copilot query
6. State persists in Redis — orchestration survives server restart mid-workflow
7. Unit tests for structured output parser (various response formats: JSON block, text-only, hybrid)
8. Unit tests for context builder (verify preamble format with various state shapes)
9. Integration test: multi-turn workflow where data accumulates across turns
10. Updated shared schemas for expanded API responses
11. No regression in existing chat functionality

## Dependencies

- v1.2 (Authentication) — for `req.user` identity on workflow state
- v1.3 (Channel Spike) — recommendation determines Copilot communication layer
- v1.4 (State Store) — persistent state with expanded model

## Risks

- **Copilot response format uncertainty**: The structured output parser must handle diverse response formats. Start with the most common patterns and add parsers as new formats are encountered. The passthrough fallback ensures nothing breaks.
- **Context window limits**: Copilot Studio agents have input limits. The context builder must truncate or summarize `stepData` if it exceeds a threshold. Start with a configurable max (e.g., 2000 chars for context preamble).
- **Race conditions**: If a user sends two messages quickly, the orchestrator must process them sequentially per conversation (use Redis WATCH or a per-conversation lock).
- **Idempotency**: If the server crashes between Copilot response and state save, the next retry may produce different Copilot output. Consider logging the raw Copilot response before parsing so it can be replayed.
